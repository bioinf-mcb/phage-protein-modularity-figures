---
title: "analyse_data"
author: "Bogna Smug"
date: '2022-09-06'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
repr.seq.lengths = data.table::fread(file = sprintf("%sprot-families/representative/repr-seqs-lengths.txt", DATA.PATH))
pairwise.hits.data = data.table::fread(sprintf("%spairwise.hits.data.txt",OUTPUT.DATA.PATH))
ecod.domains.hits = data.table::fread(sprintf("%secod.domains.hits.txt",OUTPUT.DATA.PATH))
hhr.phrogs.annotated = data.table::fread(sprintf("%shhr.phrogs.annotated.txt",OUTPUT.DATA.PATH))
ecod_id_to_names_map = data.table::fread(sprintf("%secod_id_to_names_map.txt",OUTPUT.DATA.PATH)) %>% as.data.frame()
families = data.table::fread(file = sprintf("%sfamilies.txt", OUTPUT.DATA.PATH))
protein.similarity.data = data.table::fread(file = sprintf("%sprotein.similarity.data.txt",OUTPUT.DATA.PATH))

dir.create(sprintf("%sFigure1", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure2", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure3", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure4", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure5", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure_Supplementary", OUTPUT.FIGURES.PATH))

color.map.df = PHROG.COLOR.MAP %>% stack()
names(color.map.df) = c("color", "category")
```



# Fig 1: ANNOTATION UNCERTAINTY
```{r}
num.proteins = n_distinct(repr.seq.lengths$name)

# NOTE THAT IN FIGURE 1 WE DO NOT RESTRICT OURSELVES TO CATEGORIES THAT ARE BIG ENOUGH
annotation.uncertainty.data = data.frame(annotation.coverage = character(0), minimum.probability = character(0), maximum.eval = character(0),
                                         num.prot = integer(0), num.annotated = integer(0), perc.annotated = numeric(0), perc.unique.annotation = numeric(0))


annotation.uncertainty.data.prob = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = MINIMUM.PROBABILITIES.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.prob, sprintf("%sFigure1/Fig1_Tradeoff_prob.txt", OUTPUT.FIGURES.PATH)) 

annotation.uncertainty.data.cov= Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                               max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MINIMUM.COVERAGES.FOR.ANNOTATION, 
                                                                        min.prob.range = MAIN.PROBS.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.cov, sprintf("%sFigure1/Fig1_Tradeoff_cov.txt", OUTPUT.FIGURES.PATH)) 

annotation.uncertainty.data.eval = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = NAXIMUM.EVALS.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = DEFAULT.MINIMUM.PROB.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.eval, sprintf("%sFigure1/Fig1_Tradeoff_eval.txt", OUTPUT.FIGURES.PATH)) 

```

```{r}
i=0
hhr.phrogs.list = list()
for (this.cov in MAIN.COVS.FOR.ANNOTATION) {
  i = i+1
  hhr.phrogs.list[[i]] = Get.significant.phrog.hits(hhr.phrogs.annotated, 
                                        min.prob.threshold = DEFAULT.MINIMUM.PROB.FOR.ANNOTATION, 
                                        min.qcov.threshold = this.cov, 
                                        min.scov.threshold = this.cov, 
                                        max.eval.threshold = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION) %>%
  distinct(qname, annotation, category, structural, include) %>%
  mutate(annotation.coverage = this.cov)
}

hhr.phrogs = do.call('rbind', hhr.phrogs.list)


```


```{r}
# now only look at annotations that we want to include
annotation.indexes = hhr.phrogs %>% 
  distinct(annotation, category) %>% 
  arrange(category, annotation) %>%
  mutate(annotation.index = row_number())


annotated.proteins.raw = hhr.phrogs %>%
  filter(!is.na(annotation)) %>%
  left_join(families, by = "qname") %>%
  left_join(annotation.indexes, by = c("annotation", "category")) %>% 
  select(qname, family, annotation.index, annotation, category, structural, annotation.coverage, include) 

  

relaxely.annotated.proteins.including.multi.annot = annotated.proteins.raw %>%
  filter(annotation.coverage == min(MAIN.COVS.FOR.ANNOTATION)) %>%
  select(qname, family, annotation.index, annotation, category, structural, annotation.coverage, include) %>%
  group_by(qname) %>%
  # number of annotations including the excluded ones
  mutate(num.annots = n_distinct(annotation)) %>%
  ungroup() 

surely.annotated.proteins.including.multi.annot = annotated.proteins.raw %>%
  filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
  select(qname, family, annotation.index, annotation, category, structural, annotation.coverage, include) %>%
  group_by(qname) %>%
  mutate(num.annots = n_distinct(annotation)) %>%
  ungroup() 

annotated.proteins.including.multi.annot = rbind(relaxely.annotated.proteins.including.multi.annot, surely.annotated.proteins.including.multi.annot)

# We only include categories that have MIN.NUM.PROT including the proteins with multiple annotation
included.category.sizes = annotated.proteins.including.multi.annot %>%
  group_by(annotation.index, annotation, category, structural, annotation.coverage, include) %>%
  summarise(num.seq.per.annotation = n_distinct(qname[num.annots == 1]),
            num.seq.per.annotation.including.multi.annot = n_distinct(qname)) %>%
  ungroup()  %>%
  filter(num.seq.per.annotation.including.multi.annot >= MIN.NUM.PROT & include == "TRUE") %>%
  select(-num.seq.per.annotation.including.multi.annot)

# disregard the ones with multiple annotations
surely.annotated.proteins = surely.annotated.proteins.including.multi.annot %>% filter(num.annots == 1 & include == "TRUE")
relaxely.annotated.proteins = relaxely.annotated.proteins.including.multi.annot %>% filter(num.annots == 1 & include == "TRUE")

# TODO: THIS MAY BE COMMENTED OUT
#ecod.domains.hits = ecod.domains.hits[!grepl("DEAD", ecod.domains.hits$f_name)]

surely.annotated.ecod.domains = ecod.domains.hits %>% 
  select(qname, qstart, qend, qlength, sstart, send, slength, x_id, h_id, t_id, f_id, minimum.prob) %>%
  # note that some families may be unclassified i.e. d_id = NA
  inner_join(surely.annotated.proteins)  %>%  # take the conservatively defined domains onlu
  inner_join(included.category.sizes, by = c("annotation.index", "annotation", "category", "structural", "annotation.coverage")) 


surely.annotated.ecod.domains.high.confidence =  surely.annotated.ecod.domains %>%
  filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) %>%
  select(-minimum.prob)

surely.annotated.proteins.from.included.categories = surely.annotated.proteins %>%
  inner_join(included.category.sizes) %>%
  select(qname, family, annotation.index , annotation, category)




data.table::fwrite(surely.annotated.proteins, sprintf("%ssurely.annotated.proteins.txt", OUTPUT.DATA.PATH))
data.table::fwrite(included.category.sizes, sprintf("%sincluded.category.sizes.txt", OUTPUT.DATA.PATH))
```


## Heatmap of H ECOD domains found in different functions
```{r, fig.height = 13}
h.domain.occurence.data = surely.annotated.ecod.domains.high.confidence %>% 
  distinct(qname, family, h_id, annotation, category) %>%
  group_by(annotation, category, h_id) %>%
  summarise(num.prot.with.this.h.domain = n_distinct(qname),
            num.families.with.this.h.domain = n_distinct(family)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation, category, num.seq.per.annotation)) %>%
  mutate(occurence = num.families.with.this.h.domain >= MIN.NUM.FAMILIES.FOR.ECOD.PRESENCE) %>%
  filter(occurence) %>%
  mutate(h_id = as.character(h_id)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h_id = id, h_name = name)) %>% 
         # delete singletons
         group_by(h_id) %>%
         mutate(num_annot = n_distinct(annotation)) %>%
         filter(num_annot >= 2)

data.table::fwrite(h.domain.occurence.data, sprintf("%sFigure2/H_domains.txt", OUTPUT.FIGURES.PATH))

```





#SHINY PLOTS: DOMAINS WITHIN FUNCTIONS
```{r}
# too many domains if we include "tails"
tile.data.list = list()
i=0
domain_levels = c("T")
for (this.domain.level in domain_levels) {
this.domain.level.id = paste0(tolower(this.domain.level), "_id")

  for (this.annotation in most.mosaic.annotations) {
    domains.within.this.annotation = surely.annotated.ecod.domains.high.confidence %>% 
      filter(annotation == this.annotation) %>% 
        select(qname, annotation, qlength, qstart, qend, domain = this.domain.level.id, family)  %>% 
        group_by(qname) %>%
        mutate(all.domains = paste0(sort(unique(domain)), collapse = "_and_"),
               # this is just used for ordering
               first.domain = domain[qstart == min(qstart)][1]) %>%
        ungroup() 
    
    if (nrow(domains.within.this.annotation) > 0) {
      i=i+1
      tile.data = Get.Domain.Positions.Data(
        domains.within.this.annotation %>%
          # take only one representative per each domain combination and family combination
          group_by(all.domains, family) %>%
          mutate(first.domain = first.domain[1],
                  repr.qname = qname[1]) %>%
          ungroup() %>%
          filter(repr.qname == qname) %>%
        arrange(first.domain, family)) %>%
        mutate(annotation = this.annotation,
               domain.level = this.domain.level) %>%
        left_join(families, by = "qname")
      tile.data.list[[i]] = tile.data
          
    }
  }
}

    tile.data = do.call('rbind', tile.data.list) %>%
      left_join(ecod_id_to_names_map %>% 
                  select(domain = id, domain_name = name, domain.level = level) %>%
                  rbind(expand.grid(domain.level = unique(ecod_id_to_names_map$level), 
                                    domain = c("undetected", "multiple domains")) %>%
                                   mutate(domain_name = domain)))
    
    data.table::fwrite(tile.data, sprintf("%sFigure5/domain.positions.txt", OUTPUT.FIGURES.PATH))
```



# Figure 3a: density plot
```{r}
 filtered.protein.similarity.data = protein.similarity.data %>% filter(min.hit.len >= MIN.HIT.LENGTH)
data.table::fwrite(filtered.protein.similarity.data, sprintf("%sFigure3/cov.vs.pident.txt", OUTPUT.FIGURES.PATH))
```



#Fig 4a and 4b Diversity of functional categories
```{r, fig.width = 10}
any.hit.stats = surely.annotated.ecod.domains.high.confidence %>%
  distinct(qname) %>%
  mutate(has.ecod.hit = 1) %>%
  right_join(surely.annotated.proteins %>% distinct(qname, annotation, category), by = "qname") %>%
  mutate(has.ecod.hit = if_else(is.na(has.ecod.hit), 0, has.ecod.hit)) %>%
  group_by(annotation, category) %>%
  summarise(num.proteins.with.ecod.hit = sum(has.ecod.hit)) %>%
  ungroup() %>%
  inner_join(included.category.sizes %>% filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION)) %>%
  mutate(prop.proteins.with.ecod.hit = num.proteins.with.ecod.hit/num.seq.per.annotation)

# only look at included categories (big enough)
num.families.per.annot = surely.annotated.proteins.from.included.categories %>%
  group_by(annotation, category, annotation.index) %>%
  summarise(num.families = n_distinct(family)) %>%
  ungroup()

num.domains.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(annotation, category) %>%
  summarise(num.t = n_distinct(t_id),
            num.h = n_distinct(h_id),
            num.x = n_distinct(x_id))

num.domain.combinations.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(qname, annotation, category) %>%
  summarise(all.t = paste(sort(unique(t_id)), collapse = " & "),
            all.h = paste(sort(unique(h_id)), collapse = " & "),
            all.x = paste(sort(unique(x_id)), collapse = " & ")) %>%
  group_by(annotation, category) %>%
  summarise(num.t.combinations = n_distinct(all.t),
            num.h.combinations = n_distinct(all.h),
            num.x.combinations = n_distinct(all.x))

diversity.data = num.families.per.annot %>%
  left_join(num.domains.per.annnot, by = c('annotation', 'category'))  %>%
  left_join(num.domain.combinations.per.annnot, by = c('annotation', 'category')) %>%
  left_join(any.hit.stats, by = c('annotation', 'category')) %>%
  mutate(mean.no.of.folds.per.fold.type = num.t.combinations/num.seq.per.annotation) %>%
  select(annotation, category, num.families, num.topologies = num.t, num.topology.combinations = num.t.combinations, prop.proteins.with.ecod.hit, mean.no.of.folds.per.fold.type) %>%
  mutate(poorly.ecod.annotated = prop.proteins.with.ecod.hit < MIN.PROP.PROTS.WITH.ECOD.HIT)



no.fam.plotting.thr <- floor(as.numeric(quantile(diversity.data %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.families))[4]))
no.ft.plotting.thr <- floor(as.numeric(quantile(diversity.data %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.topology.combinations))[4]))

diversity.data = diversity.data %>% 
  mutate(top.quantile = num.families >= no.fam.plotting.thr & num.topology.combinations >= no.ft.plotting.thr & !poorly.ecod.annotated) %>%
  mutate(data.type = if_else(top.quantile, "top.diversity", if_else(poorly.ecod.annotated, "poorly annotated", "low.diversity")))
  

data.table::fwrite(diversity.data, sprintf("%sFigure4/Diversity_vs_mosaicism.txt", OUTPUT.FIGURES.PATH))
```




# sequence mosaicism 
```{r}
proteins.from.most.diverse.classes = surely.annotated.proteins %>% 
  inner_join(most.diverse.classes) %>%
  distinct(qname, annotation, category)

# Only looking at pairs of proteins where both are from the same functional category
protein.pairs.from.most.diverse.classes =  protein.similarity.data %>%
  inner_join(proteins.from.most.diverse.classes %>% select(qname = qname, qannot = annotation)) %>%
  inner_join(proteins.from.most.diverse.classes %>% select(sname = qname, sannot = annotation)) %>%
  filter(qannot == sannot)
 
seq.mosaicism.from.most.diverse.classes = protein.pairs.from.most.diverse.classes %>%
  group_by(qannot) %>%
  summarise(prop.mosaic.pairs.sequence.thr0p1 = sum(mosaic.pident10)/n(),
            prop.mosaic.pairs.sequence.thr0p3 = sum(mosaic.pident30)/n(),
            prop.mosaic.pairs.sequence.thr0p5 = sum(mosaic.pident50)/n()) %>%
  select(annotation = qannot, prop.mosaic.pairs.sequence.thr0p1, prop.mosaic.pairs.sequence.thr0p3, prop.mosaic.pairs.sequence.thr0p5)


```

# Mosaicism and diversity per fold architecture (i.e. combination of domains)
```{r}
ecod.domains.in.qnames = surely.annotated.ecod.domains.high.confidence  %>%
  distinct(qname,family, annotation, category, x_id, t_id)

# first find all X level domains found
ecods.across.fold.types = ecod.domains.in.qnames %>%
  group_by(qname) %>%
  mutate(fold.type = paste(sort(unique(t_id)), collapse = " & ")) %>%
  ungroup() %>%
  distinct(t_id, x_id, fold.type, annotation, category)

all.x.and.t.within.fold.type = ecods.across.fold.types %>%
  group_by(fold.type, annotation, category) %>%
  summarise(all.x = paste(sort(unique(c(x_id))), collapse = " & "),
            num.x = n_distinct(x_id),
            num.t = n_distinct(t_id)) %>%
  ungroup()

num.folds.per.fold.type.data = all.x.and.t.within.fold.type %>%
  group_by(annotation, category) %>%
  summarise(mean.num.t = mean(num.t))

ecods.across.fold.types.data = ecods.across.fold.types %>% inner_join(all.x.and.t.within.fold.type) #%>% filter(num.x > 1)

fold.type.pairs.that.share.t = ecods.across.fold.types.data %>%
  inner_join(ecods.across.fold.types.data, by = c("annotation", "category", "t_id")) %>%
  filter(fold.type.x != fold.type.y) %>%
  left_join(ecods.across.fold.types %>% select(annotation, category, fold.type.x = fold.type, x.id.x = x_id)) %>%
  left_join(ecods.across.fold.types %>% select(annotation, category, fold.type.y = fold.type, x.id.y = x_id)) 

all.fold.type.pairs.sharing.t = fold.type.pairs.that.share.t %>%
  distinct(fold.type.x, fold.type.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(fold.type.x, fold.type.y)), collapse = " AND ", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.pairs = n_distinct(pair)) %>%
  ungroup()

fold.type.pairs.that.share.t.and.disshare.x = fold.type.pairs.that.share.t %>%
  filter(num.x.x > 1 & num.x.y > 1) %>%
  group_by(fold.type.x, fold.type.y, t_id, annotation, category) %>%
  mutate(all.x.within.both.fold.types = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ")) %>%
  ungroup() %>%
  left_join(all.x.and.t.within.fold.type %>% select(all.x.within.fold.type.x =all.x, fold.type.x = fold.type)) %>%
  left_join(all.x.and.t.within.fold.type %>% select(all.x.within.fold.type.y =all.x, fold.type.y = fold.type)) %>%
  filter(all.x.within.both.fold.types != all.x.within.fold.type.x & all.x.within.both.fold.types != all.x.within.fold.type.y) 

mosaicism.per.fold.type = fold.type.pairs.that.share.t.and.disshare.x %>%
  distinct(fold.type.x, fold.type.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(fold.type.x, fold.type.y)), collapse = " AND ", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.mosaic.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  left_join(all.fold.type.pairs.sharing.t) %>%
  mutate(prob.mosaicism = num.mosaic.pairs/num.pairs)

moaicism.per.class = diversity.data %>%
  left_join(mosaicism.per.fold.type) %>%
  left_join(num.folds.per.fold.type.data) %>%
  left_join(seq.mosaicism.from.most.diverse.classes) 

moaicism.top.diverse.classes = moaicism.per.class %>%
  filter(data.type == "top.diversity")


```


# Mosaicism and diversity per protein family
```{r shared-f-domains-not-x-domains}

ecod.domains.in.families = ecod.domains.in.qnames %>% distinct(x_id, t_id, family, annotation, category)
num.domains.per.family = ecod.domains.in.families %>%
  group_by(family, annotation, category) %>%
  summarise(num.t = n_distinct(t_id)) %>%
  ungroup() %>%
    group_by(annotation, category) %>%
    # median num t of those that have any T
  summarise(mean.num.t.per.prot = mean(num.t)) %>%
  ungroup()


# first find all X level domains found
ecods.across.families = ecod.domains.in.families %>%
  group_by(family, annotation, category) %>%
  summarise(num.x = n_distinct(x_id),
         all.x.names = paste(sort(unique(x_id)), collapse = " & ")) %>%
  ungroup() %>%
  distinct(family, annotation, category, all.x.names, num.x)

ecod.domains.in.families.data = ecod.domains.in.families %>% inner_join(ecods.across.families) #%>% filter(num.x > 1)

family.pairs.that.share.t = ecod.domains.in.families.data %>%
  inner_join(ecod.domains.in.families.data, by = c("annotation", "category", "t_id")) %>%
    filter(family.x != family.y) %>%
  left_join(ecod.domains.in.families.data %>% select(annotation, category, family.x = family, x.id.x = x_id)) %>%
  left_join(ecod.domains.in.families.data %>% select(annotation, category, family.y = family, x.id.y = x_id)) 

all.family.pairs.sharing.t = family.pairs.that.share.t %>%
  # only count pairs of families with at least two X
  filter(num.x.x > 1 & num.x.y > 1) %>%
  distinct(family.x, family.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.pairs = n_distinct(pair))

all.family.pairs.sharing.t.and.disshare.x = family.pairs.that.share.t %>%
  group_by(family.x, family.y, t_id, annotation, category) %>%
  mutate(all.x.within.both.families = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ")) %>%
  ungroup() %>%
  left_join(ecods.across.families %>% select(all.x.names.x =all.x.names, family.x = family)) %>%
  left_join(ecods.across.families %>% select(all.x.names.y =all.x.names, family.y = family)) %>%
  filter(all.x.within.both.families != all.x.names.x & all.x.within.both.families != all.x.names.y & all.x.names.y!= all.x.names.x) 

mosaicism.per.family = all.family.pairs.sharing.t.and.disshare.x %>%
  distinct(family.x, family.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.mosaic.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  left_join(all.family.pairs.sharing.t) %>%
  mutate(prob.mosaicism.if.sharing.fold.and.multi.x.family.measure = num.mosaic.pairs/num.pairs) %>%
  distinct(annotation, category, prob.mosaicism.if.sharing.fold.and.multi.x.family.measure)

moaicism.top.diverse.classes = moaicism.top.diverse.classes %>%
  left_join(mosaicism.per.family)  %>% 
  left_join(num.domains.per.family) 

data.table::fwrite(moaicism.top.diverse.classes %>%
  tidyr::gather(key = "proportion", value = "value", -c("annotation", "category")), 
  sprintf("%sFigure4/mosaicism.top.diverse.classes.txt", OUTPUT.FIGURES.PATH))
```


#FIGURE 3B MOSAICISM
#ECOD MOSAICISM
```{r}

x.domains.per.qname = ecod.domains.hits %>%
  left_join(families) %>%
  group_by(qname, family) %>%
  summarise(num.x = n_distinct(x_id),
            all.x.names = paste(sort(unique(x_id)), collapse = " & ", sep = "")) 

ecod.domains.in.qnames.wih.multi.x = ecod.domains.hits %>%
  distinct(qname, t_id,x_id) %>%
  inner_join(x.domains.per.qname %>% filter(num.x > 1)) 

qname.pairs.that.share.t = ecod.domains.in.qnames.wih.multi.x %>%
  inner_join(ecod.domains.in.qnames.wih.multi.x, by = c("t_id")) %>%
    filter(qname.x < qname.y) 

qname.pairs.sharing.t.and.disshare.x = qname.pairs.that.share.t %>%
  filter(all.x.names.y!= all.x.names.x) %>%
  left_join(ecod.domains.in.qnames.wih.multi.x %>% select(qname.x = qname, x.id.x = x_id)) %>%
  left_join(ecod.domains.in.qnames.wih.multi.x %>% select(qname.y = qname, x.id.y = x_id)) %>%
  group_by(qname.x, qname.y, t_id) %>%
  mutate(all.x.within.both.families = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ", sep = "")) %>%
  ungroup() %>%
  filter(all.x.within.both.families != all.x.names.x & all.x.within.both.families != all.x.names.y) 

qname.pairs.sharing.t.and.disshare.x.distinct = qname.pairs.sharing.t.and.disshare.x %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname.x = qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname.y = qname, annotation.index.to = annotation.index)) %>%
  distinct(qname.x, family.x, qname.y, family.y, t_id, all.x.names.x, all.x.names.y, all.x.within.both.families, annotation.index.from, annotation.index.to) %>%
  group_by(family.x, family.y) %>%
  mutate(family.pair = paste(sort(c(unique(family.x), unique(family.y))), collapse = "&", sep = "")) %>%
  ungroup()
```

#FIG 3C
# what domains are shared in mosaic pairs
```{r}
domains.shared.in.mosaic.pairs = qname.pairs.sharing.t.and.disshare.x.distinct %>%
  group_by(t_id) %>%
  summarise(num.family.pairs = n_distinct(family.pair),
            num.unknown.family.pairs = n_distinct(family.pair[is.na(annotation.index.from) | is.na(annotation.index.to)]),
            num.known.family.pairs = n_distinct(family.pair[!is.na(annotation.index.from) & !is.na(annotation.index.to)])) %>%
  ungroup() %>%
  mutate(prop.family.pairs = num.family.pairs/n_distinct(qname.pairs.sharing.t.and.disshare.x.distinct$family.pair))


domains.shared.in.mosaic.pairs$h.index <- sapply(1:nrow(domains.shared.in.mosaic.pairs), function(index){
  this.topology <- domains.shared.in.mosaic.pairs$t_id[index]
  this.topology.h.index <- strsplit(this.topology, ".", fixed = T)[[1]]
  this.topology.h.index <- this.topology.h.index[-length(this.topology.h.index)]
  this.topology.h.index <- as.character(paste(this.topology.h.index, collapse = "."))
})

domains.shared.in.mosaic.pairs = domains.shared.in.mosaic.pairs %>%
    left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h.index = id, h_name = name)) %>%
    left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) 

data.table::fwrite(domains.shared.in.mosaic.pairs, file = sprintf("%sFigure3/domains-shared-by-mosaic-pairs.txt", OUTPUT.FIGURES.PATH))
```

# Fig 3B
```{r}

seq.mosaic.pairs = protein.similarity.data %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(sname = qname, annotation.index.to = annotation.index)) %>%
  filter(mosaic & qname < sname) %>%
  left_join(families %>% select(qname,qfamily = family)) %>%
  left_join(families %>% select(sname=qname,sfamily = family)) %>%
  group_by(qfamily, sfamily) %>%
  mutate(family.pair = paste(sort(c(unique(qfamily), unique(sfamily))), collapse = "&", sep = "")) %>%
  ungroup()

seq.mosaic.pairs.from.included.funct = seq.mosaic.pairs %>%
  # narrow down to included annotations only
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.from = annotation.index) %>% 
               distinct(annotation.index.from)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.to = annotation.index) %>% 
               distinct(annotation.index.to)) %>%
  distinct(qname, sname, annotation.index.from, annotation.index.to, family.pair, qfamily, sfamily) %>%
  mutate(mosaicism.type = "seq")


ecod.mosaic.pairs.from.included.funct = 
  qname.pairs.sharing.t.and.disshare.x.distinct %>%
    # narrow down to included annotations only
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.from = annotation.index) %>% 
               distinct(annotation.index.from)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.to = annotation.index) %>% 
               distinct(annotation.index.to)) %>%
  select(qname = qname.x, sname=qname.y, annotation.index.from, annotation.index.to, family.pair, qfamily = family.x, sfamily = family.y) %>%
  distinct() %>%
  mutate(mosaicism.type = "ecod")


mosaic.pairs.from.included.funct = # we may have the same pair twice if it is both mosaic by seq and by ecod
  rbind(seq.mosaic.pairs.from.included.funct, ecod.mosaic.pairs.from.included.funct) %>%
  group_by(annotation.index.from, annotation.index.to) %>%
  summarise(
    num.families.any.mosaic = n_distinct(family.pair),
    num.family.pairs.domain = n_distinct(family.pair[mosaicism.type == "ecod"]),
    num.family.pairs.seq = n_distinct(family.pair[mosaicism.type == "seq"])) %>%
  ungroup() %>%
  filter(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM | num.family.pairs.seq >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM) %>%
    mutate(mosaicism.type = if_else(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM & num.family.pairs.seq >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM, "both",
                                    if_else(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM, "ecod","seq"))) %>%
    filter(annotation.index.from <= annotation.index.to)


mosaic.network = mosaic.pairs.from.included.funct %>%
  select(from.index = annotation.index.from, to.index = annotation.index.to, dataset = mosaicism.type, num.families.any.mosaic, num.family.pairs.domain, num.family.pairs.seq)
data.table::fwrite(mosaic.network, sprintf("%sFigure3/3a_mosaic.network.txt", OUTPUT.FIGURES.PATH))

mosaic.metadata = annotation.indexes %>%
  inner_join(num.families.per.annot, by = c("annotation.index", "annotation", "category")) %>%
  select(node = annotation.index, func = annotation, class = category, num.families)
data.table::fwrite(mosaic.metadata, sprintf("%sFigure3/3a_mosaic.metadata.txt", OUTPUT.FIGURES.PATH), sep = "\t")


```

```{r, eval = FALSE}
seq.mosaicism.between.functions = 
  seq.mosaic.pairs.from.included.funct %>%
  filter(!is.na(annotation.index.from) & !is.na(annotation.index.to)) %>%
  group_by(annotation.index.from, annotation.index.to) %>%
  summarise(num.family.pairs.seq = n_distinct(family.pair),
            mosaicism.by.seq = num.family.pairs.seq >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM)

ecod.mosaicism.between.functions = 
  ecod.mosaic.pairs.from.included.funct %>%
  #qname.pairs.sharing.t.and.disshare.x.distinct %>%
  #filter(!is.na(annotation.index.from) & !is.na(annotation.index.to)) %>%
  group_by(annotation.index.from, annotation.index.to) %>%
  summarise(
    num.family.pairs.domain = n_distinct(family.pair),
    mosaicism.by.domain = num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM)

mosaic.pairs.between.functions = seq.mosaicism.between.functions %>% 
  full_join(ecod.mosaicism.between.functions) %>%
  mutate(mosaicism.by.domain = if_else(is.na(mosaicism.by.domain), FALSE, mosaicism.by.domain),
         mosaicism.by.seq = if_else(is.na(mosaicism.by.seq), FALSE, mosaicism.by.seq),
         num.family.pairs.domain = if_else(is.na(num.family.pairs.domain), as.numeric(0), as.numeric(num.family.pairs.domain)),
         num.family.pairs.seq = if_else(is.na(num.family.pairs.seq), as.numeric(0), as.numeric(num.family.pairs.seq))) %>%
  filter(mosaicism.by.domain | mosaicism.by.seq) %>%
  mutate(mosaicism.type = if_else(mosaicism.by.seq & mosaicism.by.domain, "both", 
                                  if_else(mosaicism.by.seq, "seq", "ecod"))) 


num.annotations = length(unique(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
               pull(annotation.index)))
num.annotations.with.any.mosaic.signal = length(unique(c(mosaic.pairs.between.functions$annotation.index.from, mosaic.pairs.between.functions$annotation.index.to)))
num.annotations.with.both.mosaic.signal = length(unique(c(mosaic.pairs.between.functions %>% 
                                                            filter(mosaicism.type == "both") %>% 
                                                            pull(annotation.index.from),
                                                          mosaic.pairs.between.functions %>%
                                                            filter(mosaicism.type == "both") %>%
                                                            pull(annotation.index.to))))
    

mosaicism.between.functions = mosaic.pairs.between.functions %>%
  filter(annotation.index.from <= annotation.index.to) %>%
  distinct(annotation.index.from, annotation.index.to, mosaicism.type, num.family.pairs.domain, num.family.pairs.seq)

mosaic.network = mosaicism.between.functions %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.from = annotation.index)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.to = annotation.index)) %>%
  select(from.index = annotation.index.from, to.index = annotation.index.to, dataset = mosaicism.type, num.family.pairs.domain, num.family.pairs.seq)


data.table::fwrite(mosaic.network, sprintf("%sFigure3/3a_mosaic.network.txt", OUTPUT.FIGURES.PATH))

mosaic.metadata = annotation.indexes %>%
  inner_join(num.families.per.annot, by = c("annotation.index", "annotation", "category")) %>%
  select(node = annotation.index, func = annotation, class = category, num.families)
data.table::fwrite(mosaic.metadata, sprintf("%sFigure3/3a_mosaic.metadata.txt", OUTPUT.FIGURES.PATH), sep = "\t")


```

# new Fig 3c
```{r}

protein.similarity.data.no.self.hits = protein.similarity.data %>%
  filter(qname != sname & prob > 0 & scov > 0 & qcov > 0)
all.proteins.with.hit.to.anything = unique(c(protein.similarity.data.no.self.hits$qname, protein.similarity.data.no.self.hits$sname))
all.proteins.with.domain.mosaic.signal = unique(c(qname.pairs.sharing.t.and.disshare.x.distinct$qname.x, qname.pairs.sharing.t.and.disshare.x.distinct$qname.y))
all.proteins.with.seq.mosaic.signal = unique(c(seq.mosaic.pairs$qname, seq.mosaic.pairs$sname))
all.proteins.with.any.mosaic.signal = unique(c(all.proteins.with.domain.mosaic.signal, all.proteins.with.seq.mosaic.signal))


# look at the annotations at relaxed threhsold
all.proteins = repr.seq.lengths %>%
  select(qname = name) %>%
  distinct(qname) %>%
  mutate(mosaic = qname %in% all.proteins.with.any.mosaic.signal,
         has.hit.to.anything.in.the.data = qname %in% all.proteins.with.hit.to.anything,
         has.unknown.function = !(qname %in% surely.annotated.proteins.including.multi.annot$qname))


proteins.function.data = all.proteins %>%
  # filter(has.hit.to.anything.in.the.data & has.unknown.function) %>%
  left_join(families) %>%
  left_join(relaxely.annotated.proteins.including.multi.annot %>% select(qname, annotation, category, include)) %>%
  filter(include) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category))  %>%
  group_by(qname, family, mosaic) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))


table.seq.functions.new = proteins.function.data %>%
  group_by(family, annotation, category, mosaic) %>%
  summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category, mosaic) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight)) %>%
  mutate(mosaic = if_else(mosaic, "Mosaic", "Not mosaic")) %>%
  filter(annotation != "unknown") %>%
  group_by(mosaic) %>%
  mutate(total.weight = sum(weight)) %>%
  ungroup() %>%
  mutate(freq = weight/total.weight) 

data.table::fwrite(table.seq.functions.new, sprintf("%sFigure3/table.seq.functions.low.cov.txt", OUTPUT.FIGURES.PATH))
  
```


```{r}
domains.within.proteins = all.proteins %>%
  # filter(has.hit.to.anything.in.the.data) %>%
  left_join(families) %>%
  inner_join(ecod.domains.hits, by = "qname") %>%
  group_by(mosaic) %>%
  mutate(total.num.families.with.any.ecod.hit = n_distinct(family)) %>%
  ungroup() %>%
  distinct(qname, family, t_id, t_name, mosaic, total.num.families.with.any.ecod.hit) %>%
  group_by(t_id, t_name, mosaic, total.num.families.with.any.ecod.hit) %>%
  summarise(num.families = n_distinct(family)) %>%
  ungroup() %>%
  mutate(freq = num.families/total.num.families.with.any.ecod.hit)


domains.within.proteins$h.index <- sapply(1:nrow(domains.within.proteins), function(index){
  this.topology <- domains.within.proteins$t_id[index]
  this.topology.h.index <- strsplit(this.topology, ".", fixed = T)[[1]]
  this.topology.h.index <- this.topology.h.index[-length(this.topology.h.index)]
  this.topology.h.index <- as.character(paste(this.topology.h.index, collapse = "."))
})
domains.within.proteins = domains.within.proteins %>%
    left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h.index = id, h_name = name)) %>%
  mutate(mosaic = if_else(mosaic, "Mosaic", "Not mosaic"))

data.table::fwrite(domains.within.proteins, file = sprintf("%sFigure3/domains-in-known-and-unknown.txt", OUTPUT.FIGURES.PATH))


```

#Old  Fig 3 c and d: examine mosaic proteins of unknown function 
```{r}
# Only looking at pairsof proteins where both are from the same functional category
 unknown.proteins.mosaic.pairs.table = seq.mosaic.pairs %>%
  # filter only those where at least one protein in a mosaic pair is unknown
  filter(is.na(annotation.index.from) | is.na(annotation.index.to)) %>%
  arrange(qname, sname)

unknown.qnames.with.mosaic.signal = unknown.proteins.mosaic.pairs.table %>% 
  filter(is.na(annotation.index.from)) %>% 
  pull(qname) %>%
  unique()

unknown.snames.with.mosaic.signal = unknown.proteins.mosaic.pairs.table %>% 
  filter(is.na(annotation.index.to)) %>% 
  pull(sname) %>%
  unique()

unknown.proteins.with.any.mosaic.signal = data.frame(qname = unique(c(unknown.qnames.with.mosaic.signal, unknown.snames.with.mosaic.signal))) %>%
  left_join(families, by = "qname") %>%
  # look not only at the included categories
  left_join(relaxely.annotated.proteins.including.multi.annot, #%>% filter(include), 
            by = c("qname", "family")) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category)) %>%
  group_by(qname, family) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))

# test
aa =  unknown.proteins.with.any.mosaic.signal %>%
group_by(family, annotation, category) %>%
   summarise(weight.dispersal.within.family = max(this.annot.weight) - min(this.annot.weight))
hist(aa$weight.dispersal.within.family)

table.unknown.seq = unknown.proteins.with.any.mosaic.signal %>%
  group_by(family, annotation, category) %>%
  summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight))

data.table::fwrite(table.unknown.seq, sprintf("%sFigure3/table-unknown-seq.txt", OUTPUT.FIGURES.PATH))

```


# Fig 3 c supplementary version examine ALL proteins of unknown function 
```{r}
# Only looking at pairsof proteins where both are from the same functional category

 unknown.proteins.table = repr.seq.lengths %>%
  distinct(qname = name) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation)) %>%
  filter(is.na(annotation)) %>%
  distinct(qname) %>%
  left_join(families, by = "qname") %>%
  left_join(relaxely.annotated.proteins.including.multi.annot, #%>% filter(include), 
            by = c("qname", "family")) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category)) %>%
  group_by(qname, family) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))


table.all.unknown.seq = unknown.proteins.table %>%
  group_by(family, annotation, category) %>%
  summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight))

data.table::fwrite(table.all.unknown.seq, sprintf("%sFigure3/table-all-unknown-seq.txt", OUTPUT.FIGURES.PATH))
```




# Figure 3D OLD: ECOD mosaicism between unknown proteins and find which ECODs are shared
```{r}

unknwon.qname.pairs.sharing.t.and.disshare.x = qname.pairs.sharing.t.and.disshare.x.distinct %>%
    left_join(surely.annotated.proteins %>% distinct(qname,annotation) %>% select(qname.x = qname, annotation.x = annotation)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation) %>% select(qname.y = qname, annotation.y = annotation)) %>%
  filter(is.na(annotation.x) | is.na(annotation.y)) 

unknwon.mosaic.pairs = unknwon.qname.pairs.sharing.t.and.disshare.x %>%
  filter(qname.x < qname.y) %>%
  distinct(qname.x, qname.y, t_id, family.x, family.y) %>%
  arrange(qname.x, qname.y)  

unknwon.mosaic.family.pairs = unknwon.mosaic.pairs %>%
  distinct(family.x, family.y, t_id) %>%
  rowwise() %>%
  mutate(family.pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>% 
  distinct(t_id, family.pair)

table.unknown.ecod = unknwon.mosaic.family.pairs %>%
  group_by(t_id) %>%
  summarise(num.pairs.of.families = n_distinct(family.pair)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) %>%
  arrange(desc(num.pairs.of.families)) 

table.unknown.ecod = table.unknown.ecod %>%
  mutate(total.family.pairs = n_distinct(unknwon.mosaic.family.pairs$family.pair),
         freq = num.pairs.of.families/total.family.pairs)

table.unknowns.ecod.filename <- sprintf("%sFigure3/table-unknown-ecod.txt", OUTPUT.FIGURES.PATH)
data.table::fwrite(table.unknown.ecod, file = table.unknowns.ecod.filename)
```

```{r}
annotated.qnames = surely.annotated.ecod.domains.high.confidence %>% distinct(qname) %>% pull(qname)
ecod.hits.data.table = surely.annotated.ecod.domains.high.confidence %>% 
        distinct(qname, annotation, qlength, qstart, qend, domain = this.domain.level.id, family) %>% as.data.table()
ecod.hits.data.table = setDT(ecod.hits.data.table, key = 'qname')
seq2ecod.cov.list <- lapply(1:length(annotated.qnames), function(reprseq.index){
  this.reprseq <- annotated.qnames[reprseq.index]
  this.reprseq.hits <- ecod.hits.data.table[.(this.reprseq)]
  this.reprseq.domain.pos.list <- lapply(1:nrow(this.reprseq.hits), function(k) this.reprseq.hits$qstart[k]:this.reprseq.hits$qend[k])
  this.reprseq.domain.pos.unique <- unique(unlist(this.reprseq.domain.pos.list))
  return(ecod.pos = length(this.reprseq.domain.pos.unique))
})
seq2ecod.cov.df = data.frame(qname = annotated.qnames)
seq2ecod.cov.df$ecod.pos = seq2ecod.cov.list %>% unlist()
seq2ecod.cov.df = seq2ecod.cov.df %>%
  right_join(repr.seq.lengths %>% select(qname = name, length)) %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
    rowwise() %>%
    # those that were not in ecod data are all undetected
  mutate(num.detected.positions = if_else(is.na(ecod.pos), as.numeric(0), as.numeric(ecod.pos)))

ecod.coverage.data = seq2ecod.cov.df %>%
  group_by(annotation.index, annotation, category) %>%
  summarise(num.detected.positions = sum(num.detected.positions),
            num.all.positions = sum(length)) %>%
  ungroup() %>%
  mutate(prop.ecod.annotated.positions = num.detected.positions/num.all.positions) %>%
  select(annotation.index, annotation, category, prop.ecod.annotated.positions)

classes.with.few.ecod.annotated.prots.new = ecod.coverage.data %>%
  left_join(diversity.data %>% select(annotation, category, prop.proteins.with.ecod.hit)) %>%
  rename(`prot. with any ECOD hit` = prop.proteins.with.ecod.hit,
         `proteome covered by ECOD hits` =prop.ecod.annotated.positions) %>%
  arrange(`prot. with any ECOD hit`)

data.table::fwrite(classes.with.few.ecod.annotated.prots.new, sprintf("%sFigure_Supplementary/classes.with.few.ecod.annotated.txt", OUTPUT.FIGURES.PATH))
```

```{r, eval = FALSE}

seq.length.per.class = repr.seq.lengths %>%
  select(qname = name, length) %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
  left_join(most.diverse.classes)  %>%
  mutate(top.diversity = if_else(is.na(top.diversity),FALSE, top.diversity)) %>%
  group_by(top.diversity) %>%
  #roup_by(annotation, category, annotation.index) %>%
  summarise(mean.length = mean(length))


prop.mosaic.per.diverse.vs.nondiverse.class = repr.seq.lengths %>%
  select(qname = name, length) %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
  left_join(most.diverse.classes)  %>%
  mutate(mosaic.domain = qname  %in% all.proteins.with.domain.mosaic.signal,
         mosaic.seq = qname  %in% all.proteins.with.seq.mosaic.signal) %>%
  mutate(top.diversity = if_else(is.na(top.diversity),FALSE, top.diversity)) %>%
  group_by(top.diversity) %>%
  #group_by(annotation, category, annotation.index, top.diversity) %>%
  summarise(num.mosaic.domain = sum(mosaic.domain),
            num.not.mosaic.domain = sum(!mosaic.domain),
            num.mosaic.seq = sum(mosaic.seq),
            num.not.mosaic.seq = sum(!mosaic.seq)) %>%
  ungroup()
```




```{r}
# add some stats to diversity data
# mean seq length length and prop mosaic by sequence or domain
surely.annotated.proteins.from.included.categories %>%
  group_by(annotation.index, annoatation, category) %>%
  left_join(repr.seq.lengths %>% select(qname = name, length)) %>%
  


diversity.data %>% 
  distinct(annotation, category, poorly.ecod.annotated) %>%
  group_by(poorly.ecod.annotated) %>%
  summarise(n.classes = n())

diversity.ok.ecod = diversity.data %>% filter(!poorly.ecod.annotated)
cor.test(diversity.ok.ecod$num.families, diversity.ok.ecod$num.topology.combinations, method = "spearman")

M1 = prop.mosaic.per.diverse.vs.nondiverse.class %>% select(num.mosaic.domain, num.not.mosaic.domain) 
rownames(M1) = c("bottom", "top")
chisq.test(M1)

M2 = prop.mosaic.per.diverse.vs.nondiverse.class %>% select(num.mosaic.seq, num.not.mosaic.seq) 
rownames(M1) = c("bottom", "top")
chisq.test(M2)

moaicism.per.class %>% group_by(top.diversity) %>% summarise(mean.num.folds = mean(mean.num.t, na.rm = TRUE))
seq.length.per.class

# some of the annotated may have hits to phrog classes with < 500 seq or may have multiple hits
all.proteins %>%
  group_by(has.unknown.function) %>%
  summarise(n = n())
```
