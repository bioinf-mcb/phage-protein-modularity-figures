---
title: "analyse_data"
author: "Bogna Smug"
date: '2022-09-06'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

repr.seq.lengths = data.table::fread(file = sprintf("%sprot-families/representative/repr-seqs-lengths.txt", DATA.PATH))
pairwise.hits.data = data.table::fread(sprintf("%spairwise.hits.data.txt",OUTPUT.DATA.PATH))
ecod.domains.hits = data.table::fread(sprintf("%secod.domains.hits.txt",OUTPUT.DATA.PATH))
#hhr.phrogs = data.table::fread(sprintf("%shhr.phrogs.txt",OUTPUT.DATA.PATH))
hhr.phrogs.annotated = data.table::fread(sprintf("%shhr.phrogs.annotated.txt",OUTPUT.DATA.PATH))
ecod_id_to_names_map = data.table::fread(sprintf("%secod_id_to_names_map.txt",OUTPUT.DATA.PATH)) %>% as.data.frame()
#table.hhr = data.table::fread(sprintf("%s/prot-families/all-by-all/hhblits/table-hhr.txt", DATA.PATH))
families = data.table::fread(file = sprintf("%sfamilies.txt", OUTPUT.DATA.PATH))

dir.create(sprintf("%sFigure1", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure2", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure3", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure4", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sShiny-Plots", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sDensity-Plots", OUTPUT.FIGURES.PATH))

color.map.df = PHROG.COLOR.MAP %>% stack()
names(color.map.df) = c("color", "category")
```



# Fig 1a: ANNOTATION UNCERTAINTY
```{r}
num.proteins = n_distinct(repr.seq.lengths$name)

annotation.uncertainty.data = data.frame(annotation.coverage = character(0), minimum.probability = character(0), maximum.eval = character(0),
                                         num.prot = integer(0), num.annotated = integer(0), perc.annotated = numeric(0), perc.unique.annotation = numeric(0))


annotation.uncertainty.data.prob = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = MINIMUM.PROBABILITIES.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.prob, sprintf("%sFigure1/Fig1_Tradeoff_prob.txt", OUTPUT.FIGURES.PATH)) 

annotation.uncertainty.data.cov= Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                               max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MINIMUM.COVERAGES.FOR.ANNOTATION, 
                                                                        min.prob.range = MAIN.PROBS.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.cov, sprintf("%sFigure1/Fig1_Tradeoff_cov.txt", OUTPUT.FIGURES.PATH)) 

annotation.uncertainty.data.eval = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = NAXIMUM.EVALS.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = DEFAULT.MINIMUM.PROB.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.eval, sprintf("%sFigure1/Fig1_Tradeoff_eval.txt", OUTPUT.FIGURES.PATH)) 

```

```{r}
i=0
hhr.phrogs.list = list()
for (this.cov in MAIN.COVS.FOR.ANNOTATION) {
  i = i+1
  hhr.phrogs.list[[i]] = Get.significant.phrog.hits(hhr.phrogs.annotated, 
                                        min.prob.threshold = DEFAULT.MINIMUM.PROB.FOR.ANNOTATION, 
                                        min.qcov.threshold = this.cov, 
                                        min.scov.threshold = this.cov, 
                                        max.eval.threshold = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION) %>%
  distinct(qname, annotation, category, structural, include) %>%
  mutate(annotation.coverage = this.cov)
}

hhr.phrogs = do.call('rbind', hhr.phrogs.list)


```

# NETQWORK OF FUNCTIONS THAT COANNOTATE SAME PROTEINS
```{r}
# noe only look at annotations that we want to include
annotated.proteins = hhr.phrogs %>%
  filter(!is.na(annotation) & include == "TRUE") %>%
  left_join(families, by = "qname") %>%
  select(qname, family, annotation, category, structural, annotation.coverage) 

surely.annotated.proteins = annotated.proteins %>%
  filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
  select(qname, family, annotation, category, structural, annotation.coverage) %>%
# MAKE SURE WHERE THAT FITS %>%
  group_by(qname) %>%
  mutate(num.annots = n_distinct(annotation)) %>%
  ungroup() %>%
  filter(num.annots < 2)


included.category.sizes = annotated.proteins %>%
  group_by(annotation, category, structural, annotation.coverage) %>%
  summarise(num.seq.per.annotation = n_distinct(qname)) %>%
  arrange(desc(num.seq.per.annotation)) %>%
  ungroup()  %>%
  filter(num.seq.per.annotation >= MIN.NUM.PROT)

surely.annotated.ecod.domains = ecod.domains.hits %>% 
  select(qname, qstart, qend, qlength, sstart, send, slength, x_id, h_id, t_id, f_id, minimum.prob) %>%
  # note that some families may be unclassified i.e. d_id = NA
  inner_join(surely.annotated.proteins)  %>%  # take the conservatively defined domains onlu
  inner_join(included.category.sizes, by = c("annotation", "category", "structural", "annotation.coverage")) 


surely.annotated.ecod.domains.high.confidence =  surely.annotated.ecod.domains %>%
  filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) 

surely.annotated.proteins.from.included.categories = surely.annotated.proteins %>%
  inner_join(included.category.sizes) %>%
  select(qname, annotation, category)
  


data.table::fwrite(surely.annotated.proteins, sprintf("%ssurely.annotated.proteins.txt", OUTPUT.DATA.PATH))
data.table::fwrite(included.category.sizes, sprintf("%sincluded.category.sizes.txt", OUTPUT.DATA.PATH))
```

```{r}
# NOTE THAT WE MUST HAVE UNIQUE ANNOTATION NAMES BETWEEN CATEGORIES
annotation.sharing.data = annotated.proteins %>%
  inner_join(annotated.proteins, by = c("qname", "family", "annotation.coverage")) %>%
  filter(annotation.x != annotation.y | category.x != category.y) %>%
  rowwise() %>%
  mutate(annotation.pair = paste(sort(c(annotation.x, annotation.y)), collapse = "_&_")) %>%
  ungroup()  %>%
  dplyr::group_by(annotation.pair, annotation.coverage) %>%
  dplyr::summarise(num.seq.annotated.as.both = n_distinct(qname),
                   num.seq.families = n_distinct(family)) %>%
  tidyr::separate(col = annotation.pair, into = c("from", "to"), sep = "_&_") 

annotation.network = annotation.sharing.data %>%
  left_join(included.category.sizes %>% 
              select(from = annotation, annotation.coverage, num.seq.per.annotation.x = num.seq.per.annotation), 
            by =c('from', 'annotation.coverage')) %>%
  left_join(included.category.sizes %>% 
              select(to = annotation, annotation.coverage, num.seq.per.annotation.y = num.seq.per.annotation), 
            by =c('to', 'annotation.coverage')) %>%
  mutate(num.seq.annotated.as.either = num.seq.per.annotation.y + num.seq.per.annotation.x,
         jacard.similarity = num.seq.annotated.as.both/num.seq.annotated.as.either,
         prob.x.conditioned.y = num.seq.annotated.as.both/num.seq.per.annotation.y,
         prob.y.conditioned.x = num.seq.annotated.as.both/num.seq.per.annotation.x) %>%
  rowwise() %>%
         mutate(max.prob.conditional = max(prob.x.conditioned.y, prob.y.conditioned.x)) %>%
  ungroup() %>%
  filter(max.prob.conditional > MIN.PROB.COND.FOR.AMBIGUOUS.ANNOTATION) %>%
  arrange(from, to, annotation.coverage)


# only look at the categories that are big enough when annotated with high confidence
  node.size.and.color.map = included.category.sizes %>%
     filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
   mutate(size = 50*num.seq.per.annotation/max(num.seq.per.annotation)) %>%
   select(annotation, size, category) %>%
   left_join(color.map.df, by = "category") %>%
   select(node = annotation, color, size) %>%
   distinct()
   

data.table::fwrite(node.size.and.color.map, sprintf("%snode.size.and.color.map.txt", OUTPUT.DATA.PATH))
data.table::fwrite(annotation.network, sprintf("%sFigure1/Fig1b_Phrogs_melting.txt", OUTPUT.FIGURES.PATH))
```


#SHINY PLOTS: DOMAINS WITHIN FUNCTIONS
```{r}

tile.data.list = list()
tile.data.multi.list = list()
i=0
domain_levels = c("T", "H")
for (this.domain.level in domain_levels) {
this.domain.level.id = paste0(tolower(this.domain.level), "_id")
for (this.category in unique(surely.annotated.ecod.domains.high.confidence$category)) {
  domain.position.plots.this.category = list()
  domain.combination.plots.this.category = list()
  this.category.annotations = surely.annotated.ecod.domains.high.confidence %>% 
    filter(category == this.category) %>% 
    pull(annotation) %>% 
    unique()

  for (this.annotation in this.category.annotations) {
    domains.within.this.annotation = surely.annotated.ecod.domains.high.confidence %>% 
      filter(category == this.category & annotation == this.annotation) %>% 
        select(qname, annotation, qlength, qstart, qend, domain = this.domain.level.id)  %>% 
        group_by(qname) %>%
        arrange(qstart) %>%
      # HACK , sort by teh first domain
        mutate(family =  domain[1],
               num.domains = n_distinct(domain),
               all.domains = paste0(sort(unique(domain)), collapse = "_and_")) %>%
        ungroup() 
    
    if (nrow(domains.within.this.annotation) > 0) {
      i=i+1
      tile.data = Get.Domain.Positions.Data(
        domains.within.this.annotation) %>%
        mutate(annotation = this.annotation,
               category = this.category,
               domain.level = this.domain.level)
        tile.data.list[[i]] = tile.data
        
      tile.data.multi = Get.Domain.Positions.Data(
        domains.within.this.annotation %>%
          filter(num.domains > 1) %>%
          group_by(all.domains) %>%
          mutate(repr.qname = qname[1]) %>%
          ungroup() %>%
          filter(repr.qname == qname)) %>%
        mutate(annotation = this.annotation,
               category = this.category,
               domain.level = this.domain.level)
      tile.data.multi.list[[i]] = tile.data.multi
          
    }
  }
}
}

    tile.data = do.call('rbind', tile.data.list) %>%
      left_join(ecod_id_to_names_map %>% 
                  select(domain = id, domain_name = name, domain.level = level) %>%
                  rbind(expand.grid(domain.level = unique(ecod_id_to_names_map$level), 
                                    domain = c("undetected", "multiple domains")) %>%
                                   mutate(domain_name = domain)))
    
    tile.data.multi = do.call('rbind', tile.data.multi.list) %>%
      left_join(ecod_id_to_names_map %>% 
                  select(domain = id, domain_name = name, domain.level = level) %>%
                  rbind(expand.grid(domain.level = unique(ecod_id_to_names_map$level), 
                                    domain = c("undetected", "multiple domains")) %>%
                                   mutate(domain_name = domain)))
    
    data.table::fwrite(tile.data.multi, sprintf("%sShiny-Plots/multiple_domains.domain.positions.txt", OUTPUT.FIGURES.PATH))
    data.table::fwrite(tile.data, sprintf("%sShiny-Plots/domain.positions.txt", OUTPUT.FIGURES.PATH))

      

```

#Fig 1c: Diversity of functional categories
```{r}
num.families.per.annot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(annotation, category) %>%
  summarise(num.families = n_distinct(family)) %>%
  ungroup()

num.domains.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(annotation, category) %>%
  summarise(num.t = n_distinct(t_id),
            num.h = n_distinct(h_id),
            num.x = n_distinct(x_id))

num.domain.combinations.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(qname, annotation, category) %>%
  summarise(all.t = paste(sort(unique(t_id)), collapse = " & "),
            all.h = paste(sort(unique(h_id)), collapse = " & "),
            all.x = paste(sort(unique(x_id)), collapse = " & ")) %>%
  group_by(annotation, category) %>%
  summarise(num.t.combinations = n_distinct(all.t),
            num.h.combinations = n_distinct(all.h),
            num.x.combinations = n_distinct(all.x))

diversity.data = num.families.per.annot %>%
  inner_join(num.domains.per.annnot, by = c('annotation', 'category'))  %>%
  inner_join(num.domain.combinations.per.annnot, by = c('annotation', 'category')) %>%
  select(annotation, category, num.families, num.topologies = num.t, num.topology.combinations = num.t.combinations) 

data.table::fwrite(diversity.data, sprintf("%sFigure1/Fig1_Diversity_vs_mosaicism.txt", OUTPUT.FIGURES.PATH))

```

## Heatmap of H ECOD domains found in different functions
```{r, fig.height = 13}
h.domain.occurence.data = surely.annotated.ecod.domains.high.confidence %>% 
  distinct(qname, family, h_id, annotation, category) %>%
  group_by(annotation, category, h_id) %>%
  summarise(num.prot.with.this.h.domain = n_distinct(qname),
            num.families.with.this.h.domain = n_distinct(family)) %>%
  inner_join(included.category.sizes %>% filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% select(annotation, category, num.seq.per.annotation)) %>%
  mutate(occurence = num.families.with.this.h.domain >= MIN.NUM.ECOD.MOSAIC.PAIR.FAMILIES.BETWEEN.FUNCTIONS,
         #occurence = 100*num.prot.with.this.h.domain/num.seq.per.annotation >= MIN.PERC.PROTEINS.WITH.H.DOMAIN,
         prop = num.prot.with.this.h.domain/num.seq.per.annotation) %>%
  filter(occurence) %>%
  mutate(h_id = as.character(h_id)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h_id = id, h_name = name))

data.table::fwrite(h.domain.occurence.data, sprintf("%sFigure2/H_domains.txt", OUTPUT.FIGURES.PATH))

```

# Fig 2b: network of annotations on low cov: connect the ones that appear at least in 3 families 
```{r}
annotation.network.low.cov = annotation.sharing.data %>%
  filter(annotation.coverage == min(MAIN.COVS.FOR.ANNOTATION)) %>%
  filter(num.seq.families >= MIN.NUM.ECOD.MOSAIC.PAIR.FAMILIES.BETWEEN.FUNCTIONS) %>%
  distinct(from, to) %>%
  arrange(from, to)


data.table::fwrite(annotation.network.low.cov, sprintf("%sFigure2/Fig2b_shared_annotations.txt", OUTPUT.FIGURES.PATH))

```


# Mosaicism
```{r shared-f-domains-not-x=domains}
surely.annotated.ecod.domains$domain_level = surely.annotated.ecod.domains %>% pull(SHARED.DOMAIN.LEVEL)
ecod.domains.in.qnames = surely.annotated.ecod.domains  %>%
  distinct(qname, x_id, h_id, t_id, f_id, domain_level, minimum.prob)

# first find all X level domains found on conservative prob. threshold (can change that to relaxed)
qnames.with.multiple.x.groups = ecod.domains.in.qnames %>%
  group_by(qname) %>%
  mutate(num.x = n_distinct(x_id[minimum.prob == MINIMUM.PROB.FOR.DOMAIN]),
         all.x.names.conservative.threshold = paste(sort(unique(x_id[minimum.prob == MINIMUM.PROB.FOR.DOMAIN])), collapse = " & ")) %>%
  filter(num.x > 1) %>%
  ungroup()


# and find shared F domains found on conservative threshold
shared.f.domain.data = qnames.with.multiple.x.groups %>% filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) %>%
  inner_join(qnames.with.multiple.x.groups %>% filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN), by = "domain_level") %>%
  filter(qname.x != qname.y)


pairs.that.share.f.and.disshare.x = shared.f.domain.data %>%
  filter(all.x.names.conservative.threshold.x != all.x.names.conservative.threshold.y) %>% 
  distinct(qname.x, qname.y, all.x.names.conservative.threshold.x, all.x.names.conservative.threshold.y) %>%
  # find all x domains on conservative threshold
  left_join(ecod.domains.in.qnames %>% 
              filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) %>% 
              distinct(qname, x_id) %>% 
              select(qname.x = qname, x_id.x = x_id), by = "qname.x") %>%
  left_join(ecod.domains.in.qnames %>% 
              filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) %>% 
              distinct(qname, x_id) %>% 
              select(qname.y = qname, x_id.y = x_id), by = "qname.y") %>%
  group_by(qname.x, qname.y, all.x.names.conservative.threshold.x, all.x.names.conservative.threshold.y) %>%
  summarise(all.x.names.conservative.per.pair = paste(sort(unique(c(x_id.x, x_id.y))), collapse = " & ", sep = "")) %>%
  ungroup() %>%
  filter(all.x.names.conservative.per.pair != all.x.names.conservative.threshold.x & 
         all.x.names.conservative.per.pair != all.x.names.conservative.threshold.y)
  

pairs.with.distinct.x.and.same.f = pairs.that.share.f.and.disshare.x %>%
  distinct(qname.x, qname.y) %>%
  inner_join(surely.annotated.proteins  %>%
      select(qname.x = qname, family.x = family, annotation.x = annotation, category.x = category), by = "qname.x") %>% 
  inner_join(surely.annotated.proteins  %>%
      select(qname.y = qname, family.y = family, annotation.y = annotation, category.y = category), by = "qname.y") %>% 
  rowwise() %>%
  mutate(pair = paste(sort(c(qname.x, qname.y)), collapse = "&", sep = "")) %>%
  mutate(family.pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = ""))

```

```{r, fig.wisth = 10, fig.height=10}
mosaicism.between.and.within.annotations = pairs.with.distinct.x.and.same.f %>%
  group_by(annotation.x, annotation.y, category.x, category.y) %>%
  summarise(num.pairs = n_distinct(pair),
            num.family.pairs = n_distinct(family.pair)) %>%
  ungroup() %>%
  filter(num.pairs > MIN.NUM.ECOD.MOSAIC.PAIRS.BETWEEN.FUNCTIONS,
         num.family.pairs >= MIN.NUM.ECOD.MOSAIC.PAIR.FAMILIES.BETWEEN.FUNCTIONS) %>%
  distinct(annotation.x, annotation.y, category.x, category.y) %>%
  mutate(mosaicism.occurence = TRUE,
         same.category = category.x == category.y) %>%
  mutate(type = if_else(same.category, category.x, "different.cat")) %>%
  distinct(annotation.x, annotation.y, category.x, category.y, type) %>%
  tidyr::complete(tidyr::nesting(annotation.x, category.x),tidyr::nesting( annotation.y, category.y), fill = list(type = "not mosaic")) 


annotation.order.in.plot = mosaicism.between.and.within.annotations %>% 
                                        distinct(category.x, annotation.x) %>%
                                        arrange(category.x, annotation.x) %>%
                                        select(category = category.x, annotation = annotation.x) %>%
                                        mutate(pos = row_number())
  

mosaicism.between.and.within.annotations = mosaicism.between.and.within.annotations %>%
  left_join(annotation.order.in.plot %>% select(category.x = category, annotation.x = annotation, pos.x = pos)) %>%
  left_join(annotation.order.in.plot %>% select(category.y = category, annotation.y = annotation, pos.y = pos)) %>%
 filter(pos.x <= pos.y)

data.table::fwrite(mosaicism.between.and.within.annotations, file = sprintf("%sFigure3/Fig3b_mosaicism_between_and_within_f.txt", OUTPUT.FIGURES.PATH))
```

# ECOD mosaicism between functions
```{r}
pairs.with.distinct.x.and.same.f.distinct.annots = pairs.with.distinct.x.and.same.f %>%
    filter(annotation.x != annotation.y) 


mosaicism.between.annotations = pairs.with.distinct.x.and.same.f.distinct.annots %>%
  group_by(annotation.x, annotation.y, category.x, category.y) %>%
  summarise(num.pairs = n_distinct(pair),
            num.family.pairs = n_distinct(family.pair)) %>%
  ungroup() %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.x = annotation, category.x = category, num.seq.per.annotation.x = num.seq.per.annotation)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.y = annotation, category.y = category, num.seq.per.annotation.y = num.seq.per.annotation)) 


network.mosaicism.between.annotations = mosaicism.between.annotations %>%
  filter(num.pairs > MIN.NUM.ECOD.MOSAIC.PAIRS.BETWEEN.FUNCTIONS,
         num.family.pairs >= MIN.NUM.ECOD.MOSAIC.PAIR.FAMILIES.BETWEEN.FUNCTIONS) %>%
  select(from = annotation.x, to = annotation.y)

data.table::fwrite(network.mosaicism.between.annotations, sprintf("%sFigure3/Fig3a_Mosaicism_between_functions.txt", OUTPUT.FIGURES.PATH))
```




# ECOD MOSAICISM WITHIN FUNCTIONS
```{r}

# per qname: num pairs it is in where f domain is shared and one x domain is disshared / num pairs it is in where f domain is shared and at least two x domains are present
num.prots.with.multiple.domains = qnames.with.multiple.x.groups %>%
      inner_join(surely.annotated.proteins  %>%
      select(qname, annotation, category), by = "qname") %>% 
  group_by(annotation, category) %>%
  summarise(num.prots.with.2.x.domains = n_distinct(qname))
 
num.pairs.per.annot.f.domain.shared = shared.f.domain.data %>%
    inner_join(surely.annotated.proteins  %>%
      select(qname.x = qname, family.x = family, annotation.x = annotation, category.x = category), by = "qname.x") %>% 
  inner_join(surely.annotated.proteins  %>%
      select(qname.y = qname, family.y = family, annotation.y = annotation, category.y = category), by = "qname.y") %>% 
  rowwise() %>%
  mutate(pair = paste(sort(c(qname.x, qname.y)), collapse = "&", sep = "")) %>%
  filter(annotation.x == annotation.y) %>%
  group_by(annotation.x, category.x) %>%
  summarise(num.pairs.f.shared = n_distinct(pair)) %>%
  select(annotation = annotation.x, category = category.x, num.pairs.f.shared)


num.pairs.f.domain.shared.and.x.domain.disshared.per.annot = pairs.with.distinct.x.and.same.f %>%
  filter(annotation.x == annotation.y) %>%
  group_by(annotation.x, category.x) %>%
  summarise(num.pairs.f.shared.and.x.disshared = n_distinct(pair),
            num.family.pairs.f.shared.and.x.disshared = n_distinct(family.pair)) %>%
  select(annotation = annotation.x, category = category.x, num.pairs.f.shared.and.x.disshared, num.family.pairs.f.shared.and.x.disshared)



domain.sharing.par.number.data = num.pairs.per.annot.f.domain.shared %>%
  left_join(num.pairs.f.domain.shared.and.x.domain.disshared.per.annot, by = c("annotation", "category")) %>%
  left_join(num.prots.with.multiple.domains, by = c("annotation", "category")) %>%
  rowwise() %>%
  mutate(num.pairs.f.shared = if_else(is.na(num.pairs.f.shared), 0, as.numeric(num.pairs.f.shared)), 
         num.pairs.f.shared.and.x.disshared = if_else(is.na(num.pairs.f.shared.and.x.disshared), 0, as.numeric(num.pairs.f.shared.and.x.disshared)),
         num.family.pairs.f.shared.and.x.disshared = if_else(is.na(num.family.pairs.f.shared.and.x.disshared), 0, as.numeric(num.family.pairs.f.shared.and.x.disshared))) %>%
  ungroup() %>%
  mutate(prob.moisaicism.cond.shared.f = num.pairs.f.shared.and.x.disshared/num.pairs.f.shared) 


domain.sharing.par.number.data.most.popular.annotations.only = domain.sharing.par.number.data %>%
  inner_join(included.category.sizes %>% filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% select(annotation, category)) %>%
  filter(num.family.pairs.f.shared.and.x.disshared > MIN.NUM.ECOD.MOSAIC.PAIR.FAMILIES.WITHIN.FUNCTIONS) %>%
  filter(num.prots.with.2.x.domains > MIN.NUM.PROT.WITH.2.X.DOMAINS) %>%
  arrange(category, annotation) 
data.table::fwrite(domain.sharing.par.number.data.most.popular.annotations.only, sprintf("%sFigure4/Fig4a_Mosaicism_within_class_min_3_family_pairs.txt", OUTPUT.FIGURES.PATH))
```


# HEATMAPS OF HITS
```{r}
 annotated.hhr.table = protein.similarity.data %>%
   # note that here a protein pair will appear in multiple times if they  have multiple annotations
  inner_join(surely.annotated.proteins.from.included.categories %>% distinct(qname,annotation) %>% select(qname, qannotation = annotation)) %>%
  inner_join(surely.annotated.proteins.from.included.categories %>% distinct(qname,annotation) %>% select(sname = qname, sannotation = annotation)) %>%
   mutate(hit.length = qlength*qcov) %>%
   filter(prob >= MINIMUM.PROB.FOR.PAIRWISE.HIT/100) %>%
   filter(hit.length > MIN.HIT.LENGTH)

  annotated.hhr.table$max.cov = apply(cbind(annotated.hhr.table$scov, annotated.hhr.table$qcov), 1, max, na.rm = T)
data.table::fwrite(annotated.hhr.table, sprintf("%sDensity-Plots/cov.vs.pident.txt", OUTPUT.FIGURES.PATH))
```








# TO BE CONTINUED



# SEQUENCE MOSAICISM
# TO BE CHECKED
```{r, fig.width = 10, eval = FALSE}
prots.with.any.hit = data.frame(
  qname = unique(c(pairwise.hits.data %>% filter(qname != sname) %>%  pull(qname), pairwise.hits.data  %>% filter(qname != sname) %>% pull(sname)))) %>%
  mutate(has.any.hit = TRUE)
  
prots.with.mosaicism.signal = data.frame(
  qname = unique(c(pairwise.hits.data %>% filter(!similar.proteins) %>% pull(qname),
                   pairwise.hits.data %>% filter(!similar.proteins) %>% pull(sname)))) %>%
  mutate(has.mosaicism.signal = TRUE)

prots.with.mosaicism.signal.annotated = annotated.proteins  %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
  left_join(prots.with.any.hit, by = "qname") %>%
  left_join(prots.with.mosaicism.signal, by = "qname") %>%
  group_by(annotation, category, structural, annotation.coverage) %>%
  summarise(n.mosaic.prots = n_distinct(qname[has.mosaicism.signal]),
            n.prots.with.any.hit = n_distinct(qname[has.any.hit])) %>%
  left_join(included.category.sizes) %>%
  mutate(#perc.mosaic.prots = n.mosaic.prots/num.seq.per.annotation
    perc.mosaic.prots = n.mosaic.prots/n.prots.with.any.hit) 

prots.with.mosaicism.signal.annotated$annotation = factor(prots.with.mosaicism.signal.annotated$annotation,
                                                          levels = prots.with.mosaicism.signal.annotated %>%
                                                            arrange(category, desc(perc.mosaic.prots)) %>%
                                                            pull(annotation) %>% unique())
ggplot(prots.with.mosaicism.signal.annotated) +
  geom_col(aes(x = annotation, y = perc.mosaic.prots, fill = category)) +
  facet_grid(.~category, scales = "free") + 
  guides(fill = "none") +
  Get.Theme(text_size = 4) +
  scale_fill_manual(values = PHROG.COLOR.MAP) + xlab("") + ylab("P(having mosaic signal | having any similarity to another protein")

ggsave(sprintf("%sFigure4/Fig4b_Perc.prot.with.mosaic.jpg", OUTPUT.FIGURES.PATH), width = 1.3*FIG.WIDTH, height = FIG.HEIGHT, units = "cm")
```

# MAP FRAGMENTS WITH TAXONOMY AND SEQUENCE MOSAICISM: TODO
```{r, eval = FALSE}
annotated.pairwise.hits = pairwise.hits.data %>%
  filter(!similar.proteins) %>%
  inner_join(annotated.proteins %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
               select(qname, qannotation = annotation, qcategory = category)) %>%
  inner_join(annotated.proteins %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
               select(sname = qname, sannotation = annotation, scategory = category))

categories = unique(c(annotated.pairwise.hits$qcategory, annotated.pairwise.hits$scategory))
for (this.category in categories) {
  num.dissimila.pairs.that.share.fragment = annotated.pairwise.hits %>%
    group_by(qannotation, sannotation) %>%
    summarise(n = n_distinct(paste0(sort(c(qname, sname)))))
  
  ggplot(num.dissimila.pairs.that.share.fragment) + 
    geom_tile(aes(qannotation, sanotation, fill = n))
}
  
```




```{r, eval = FALSE}

metadata = read.csv(file = GENOME_METADATA.PATH,
                     header = TRUE)
represeq.name.table = read.csv(file = sprintf("%sprot-families/representative/name-table.txt", DATA.PATH),
                     header = TRUE) 


represeq.name.table$accession = sapply(represeq.name.table$prot.name, FUN = function (str) {base::strsplit(str, split = "\\.")[[1]][1]})

prot.name.meta.data = metadata %>% 
  select(accession = Accession, family = Family, host = Host, genome.length = Length) %>%
  right_join(represeq.name.table, by = "accession") %>%
  select(qname = repr.name, family, host, genome.length, prot.name)

all.proteins.with.meta.data = annotated.proteins %>% 
  left_join(prot.name.meta.data, by = "qname")


all.annotated.hits.with.meda.data = all.annotated.hits %>%
  inner_join(prot.name.meta.data %>% distinct(qname, family, length) %>% select(qname = qname, qfamily = family, qlength = length)) %>%
  inner_join(prot.name.meta.data %>% distinct(qname, family, length) %>% select(sname = qname, sfamily = family, slength = length))
```
