---
title: "analyse_data"
author: "Bogna Smug"
date: '2022-09-06'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
families = data.table::fread(file = sprintf("%sfamilies.txt", OUTPUT.DATA.PATH))
protein.similarity.data = data.table::fread(file = sprintf("%sprotein.similarity.data.txt",OUTPUT.DATA.PATH))


repr.seq.lengths = data.table::fread(file = sprintf("%sprot-families/representative/repr-seqs-lengths.txt", DATA.PATH))
ecod.domains.hits = data.table::fread(sprintf("%secod.domains.hits.txt",OUTPUT.DATA.PATH))
# make sure ecod indexes are characters not numeric
index.cols = which(names(ecod.domains.hits) %in% c("x_id", "h_id", "t_id", "f_id"))
ecod.domains.hits[ , (index.cols) := lapply(.SD, as.character), .SDcols = index.cols]


hhr.phrogs.annotated = data.table::fread(sprintf("%shhr.phrogs.annotated.txt",OUTPUT.DATA.PATH))
hhr.phrogs = data.table::fread(sprintf("%shhr.phrogs",OUTPUT.DATA.PATH))
ecod_id_to_names_map = data.table::fread(sprintf("%secod_id_to_names_map.txt",OUTPUT.DATA.PATH)) %>% as.data.frame()

surely.annotated.proteins.including.multi.annot = data.table::fread( sprintf("%ssurely.annotated.proteins.including.multi.annot",OUTPUT.DATA.PATH))  %>%
  left_join(families)
relaxely.annotated.proteins.including.multi.annot =data.table::fread(sprintf("%srelaxely.annotated.proteins.including.multi.annot",OUTPUT.DATA.PATH)) %>%
  left_join(families)
mid.annotated.proteins.including.multi.annot =data.table::fread(sprintf("%smid.annotated.proteins.including.multi.annot",OUTPUT.DATA.PATH)) %>%
  left_join(families)
included.category.sizes = data.table::fread(sprintf("%sincluded.category.sizes",OUTPUT.DATA.PATH))

# disregard the ones with multiple annotations
surely.annotated.proteins = surely.annotated.proteins.including.multi.annot %>% filter(num.annots == 1 & include == "TRUE")
relaxely.annotated.proteins = relaxely.annotated.proteins.including.multi.annot %>% filter(num.annots == 1 & include == "TRUE")  
data.table::fwrite(surely.annotated.proteins, sprintf("%ssurely.annotated.proteins.txt", OUTPUT.DATA.PATH))


classes = rep("character", 16)
ecod.domain.descriptions = read.delim(ECOD.DOMAIN.DESCRIPTION.FILEPATH, 
                                      skip = 4, header = TRUE, 
                                      colClasses = classes, sep = "\t")

dir.create(sprintf("%sFigure1", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure2", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure3", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure4", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure5", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure_Alternatives", OUTPUT.FIGURES.PATH))
dir.create(sprintf("%sFigure_Supplementary", OUTPUT.FIGURES.PATH))

color.map.df = PHROG.COLOR.MAP %>% stack()
names(color.map.df) = c("color", "category")
```




# Fig 1: ANNOTATION UNCERTAINTY
```{r, eval = FALSE}
num.proteins = n_distinct(repr.seq.lengths$name)

# NOTE THAT IN FIGURE 1 WE DO NOT RESTRICT OURSELVES TO CATEGORIES THAT ARE BIG ENOUGH
annotation.uncertainty.data = data.frame(annotation.coverage = character(0), minimum.probability = character(0), maximum.eval = character(0),
                                         num.prot = integer(0), num.annotated = integer(0), perc.annotated = numeric(0), perc.unique.annotation = numeric(0))


annotation.uncertainty.data.prob = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = MINIMUM.PROBABILITIES.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.prob, sprintf("%sFigure1/Fig1_Tradeoff_prob.txt", OUTPUT.FIGURES.PATH)) 

annotation.uncertainty.data.cov= Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                               max.eval.range = DEFAULT.NAXIMUM.EVAL.FOR.ANNOTATION, 
                                                                        min.cov.range = MINIMUM.COVERAGES.FOR.ANNOTATION, 
                                                                        min.prob.range = MAIN.PROBS.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.cov, sprintf("%sFigure1/Fig1_Tradeoff_cov.txt", OUTPUT.FIGURES.PATH)) 
```

```{r, eval = FALSE}
annotation.uncertainty.data.eval = Calculate.Annotation.Tradeoff(hhr.phrogs.annotated,
                                                                 max.eval.range = NAXIMUM.EVALS.FOR.ANNOTATION, 
                                                                        min.cov.range = MAIN.COVS.FOR.ANNOTATION, 
                                                                        min.prob.range = DEFAULT.MINIMUM.PROB.FOR.ANNOTATION)
data.table::fwrite(annotation.uncertainty.data.eval, sprintf("%sFigure1/Fig1_Tradeoff_eval.txt", OUTPUT.FIGURES.PATH)) 

```


```{r}
included.categories = included.category.sizes %>% 
  filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
  distinct(annotation.index)

node.color.map = included.category.sizes %>% 
                                      filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
                                      select(annotation.index, category) %>%
                                      left_join(color.map.df, by = "category") %>%
                                      select(node = annotation.index, color)
 node.size.map = included.category.sizes %>% 
                                      filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
                                      mutate(node = annotation.index, size = num.seq.per.annotation/100) %>%
                                      select(node, size)
node.labels = included.category.sizes %>% 
                                      filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>%
                                      rowwise() %>%
                                      mutate(annot = gsub(" ", "\n", annotation)) %>%
                                      select(node = annotation.index, label = annot)
annotation.network.metadata = node.color.map %>%
  inner_join(node.size.map, by = "node") %>%
  inner_join(node.labels, by = "node")
```

```{r}
included.proteins.relaxely.annotated =   mid.annotated.proteins.including.multi.annot %>%
  #relaxely.annotated.proteins.including.multi.annot %>%
  inner_join(included.categories) %>% 
  distinct(annotation.index, qname)

annotation.netwok.relaxed.threshold = included.proteins.relaxely.annotated %>%
  inner_join(included.proteins.relaxely.annotated, by = "qname") %>%
  filter(annotation.index.x != annotation.index.y) %>%
  group_by(annotation.index.x, annotation.index.y) %>%
  summarise(n = n_distinct(qname)) %>%
  ungroup() %>%
  filter(n >= MIN.NUM.SHARED.SEQ.FOR.SHARED.ANNOT.GRAPH) %>%
  select(from = annotation.index.x, to = annotation.index.y)


included.proteins.surely.annotated =   surely.annotated.proteins.including.multi.annot %>%
  inner_join(included.categories) %>% 
  distinct(annotation.index, qname)

annotation.netwok.default.threshold = included.proteins.surely.annotated %>%
  inner_join(included.proteins.surely.annotated, by = "qname") %>%
  filter(annotation.index.x != annotation.index.y) %>%
  group_by(annotation.index.x, annotation.index.y) %>%
  summarise(n = n_distinct(qname)) %>%
  ungroup() %>%
  filter(n >= MIN.NUM.SHARED.SEQ.FOR.SHARED.ANNOT.GRAPH) %>%
  select(from = annotation.index.x, to = annotation.index.y)




data.table::fwrite(annotation.netwok.relaxed.threshold, 
                   sprintf("%sFigure1/annotation.netwok.relaxed.threshold.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(annotation.netwok.default.threshold, 
                   sprintf("%sFigure1/annotation.netwok.default.threshold.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(annotation.network.metadata, 
                   sprintf("%sFigure1/annotation.network.metadata.txt", OUTPUT.FIGURES.PATH))
```

```{r}
surely.annotated.ecod.domains = ecod.domains.hits %>% 
  select(qname, qstart, qend, qlength, sstart, send, slength, x_id, h_id, t_id, f_id, minimum.prob) %>%
  # note that some families may be unclassified i.e. d_id = NA
  inner_join(surely.annotated.proteins)  %>%  # take the conservatively defined domains onlu
  inner_join(included.category.sizes, by = c("annotation.index", "annotation", "category", "structural", "annotation.coverage", "include")) 

surely.annotated.ecod.domains.high.confidence =  surely.annotated.ecod.domains %>%
  filter(minimum.prob == MINIMUM.PROB.FOR.DOMAIN) %>%
  select(-minimum.prob)

surely.annotated.proteins.from.included.categories = surely.annotated.proteins %>%
  inner_join(included.category.sizes) %>%
  select(qname, family, annotation.index , annotation, category)
```

## Heatmap of H ECOD domains found in different functions
```{r, fig.height = 13}
h.domain.occurence.data = surely.annotated.ecod.domains.high.confidence %>% 
  distinct(qname, family, h_id, annotation, category) %>%
  group_by(annotation, category, h_id) %>%
  summarise(num.prot.with.this.h.domain = n_distinct(qname),
            num.families.with.this.h.domain = n_distinct(family)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation, category, num.seq.per.annotation)) %>%
  #mutate(occurence = num.families.with.this.h.domain >= MIN.NUM.FAMILIES.FOR.ECOD.PRESENCE) %>%
  mutate(occurence = num.prot.with.this.h.domain >= MIN.NUM.REPRSEQS.FOR.ECOD.PRESENCE) %>%
  filter(occurence) %>%
  mutate(h_id = as.character(h_id)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h_id = id, h_name = name)) %>%
         # delete singletons
         group_by(h_id) %>%
         mutate(num_annot = n_distinct(annotation)) %>%
         filter(num_annot >= 3) %>%
  group_by(h_name) %>%
  mutate(num.categories = n_distinct(category)) %>%
  mutate(all.categories = if_else(num.categories == 1, 
                                  category, 
                                  "multiple categories")) %>%
  ungroup()



data.table::fwrite(h.domain.occurence.data, sprintf("%sFigure2/H_domains.txt", OUTPUT.FIGURES.PATH))


#ecod.domain.descriptions$h_id <- sapply(1:nrow(ecod.domain.descriptions), function(index){
#  this.topology <- ecod.domain.descriptions$f_id[index]
#  this.topology.numbers <- strsplit(this.topology, ".", fixed = T)[[1]]
#  this.topology.h.index <- this.topology.numbers[1:2] %>% paste(collapse = ".")
#})
#
#ecod.domain.descriptions$t_id <- sapply(1:nrow(ecod.domain.descriptions), function(index){
#  this.topology <- ecod.domain.descriptions$f_id[index]
#  this.topology.numbers <- strsplit(this.topology, ".", fixed = T)[[1]]
#  this.topology.t.index <- this.topology.numbers[1:2:3] %>% paste(collapse = ".")
#})


#num.f.within.h = 
#ecod.domain.descriptions %>% group_by(h_id) %>% summarise(num_f = n_distinct(f_id), num_t = n_distinct(t_id)) %>%
#  inner_join(h.domain.occurence.data %>% distinct(h_id, h_name, all.categories)) %>%
#  distinct(h_name, num_f, num_t, all.categories)

num.f.within.h = 
surely.annotated.ecod.domains.high.confidence  %>% group_by(h_id) %>% summarise(num_f = n_distinct(f_id), num_t = n_distinct(t_id), num_prot = n_distinct(qname)) %>%
  left_join(h.domain.occurence.data %>% distinct(h_id, h_name, all.categories) %>% mutate(in.ecod.heatmap = TRUE)) %>%
  distinct(h_name, num_f, num_t, num_prot, all.categories, in.ecod.heatmap)

data.table::fwrite(num.f.within.h, sprintf("%sFigure2/num.f.within.h.txt", OUTPUT.FIGURES.PATH))





t.domain.occurence.data.full = surely.annotated.ecod.domains.high.confidence %>% 
  distinct(qname, family, t_id, annotation, category) %>%
  group_by(annotation, category, t_id) %>%
  summarise(num.prot.with.this.t.domain = n_distinct(qname),
            num.families.with.this.h.domain = n_distinct(family)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation, category, num.seq.per.annotation)) %>%
  #mutate(occurence = num.families.with.this.h.domain >= MIN.NUM.FAMILIES.FOR.ECOD.PRESENCE) %>%
  mutate(occurence = num.prot.with.this.t.domain >= MIN.NUM.REPRSEQS.FOR.ECOD.PRESENCE) %>%
  filter(occurence) %>%
  mutate(t_id = as.character(t_id)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) %>%
  group_by(t_name) %>%
  mutate(num.categories = n_distinct(category)) %>%
  mutate(all.categories = if_else(num.categories == 1, 
                                  category, 
                                  "multiple categories")) %>%
  ungroup()
data.table::fwrite(t.domain.occurence.data.full, sprintf("%sFigure2/T_domains.txt", OUTPUT.FIGURES.PATH))



```









# Figure 3a: density plot
```{r}
# only filter to those with minimum length and high probability
 filtered.protein.similarity.data = protein.similarity.data %>% filter(share.any.fragment)
data.table::fwrite(filtered.protein.similarity.data, sprintf("%sFigure3/cov.vs.pident.txt", OUTPUT.FIGURES.PATH))
```

# network of DNA, RNA, and nucleotide metabolism domains
```{r}
selected_categories = c("DNA, RNA and nucleotide metabolism","tail", "lysis")
nucl.metabolism.domain.network = data.frame(from = character(0), to = character(0), category = character(0), num.prot = numeric(0))


for (selected_category in selected_categories) {
  nucl.metabolism.domains.in.selected.category = surely.annotated.ecod.domains.high.confidence %>%
    filter(category == selected_category) %>%
    distinct(t_id, category)
  # here we look only at sequences that include a domain from selected category
  nucl.metabolism.domain.hits = surely.annotated.ecod.domains.high.confidence %>%
    inner_join(nucl.metabolism.domains.in.selected.category, by = c("t_id", "category")) %>%
    distinct(qname, t_id, category)
  # and we see what other doains coexist with these domains
  nucl.metabolism.domain.network.this.cat = nucl.metabolism.domain.hits %>%
    inner_join(nucl.metabolism.domain.hits, by = c("qname", "category")) %>%
    filter(t_id.x < t_id.y) %>%
    rowwise() %>%
    mutate(pair = paste(sort(c(t_id.x, t_id.y)), collapse = " AND ", sep = ""),
           category = selected_category) %>%
    group_by(t_id.x, t_id.y, pair, category) %>%
    summarise(num.prot = n_distinct(qname)) %>%
    ungroup() %>%
    select(from = t_id.x, to = t_id.y, category, num.prot) %>%
    filter(num.prot >= 5)
    nucl.metabolism.domain.network = rbind(nucl.metabolism.domain.network, nucl.metabolism.domain.network.this.cat)
}



  domain.annotations = surely.annotated.ecod.domains.high.confidence %>%
    filter(category %in% selected_categories)  %>%
    distinct(t_id, annotation, category) %>%
    group_by(t_id, category) %>%
    mutate(n = n_distinct(annotation)) %>%
    arrange(t_id) %>%
    summarise(annotation = if_else(all(n == 1), annotation[1], "multiple")) %>%
    left_join(stack(PHROG.COLOR.MAP) %>% select(color = values, category = ind), by = "category") %>%
    mutate(multi = annotation == "multiple")  %>%
    mutate(color = if_else(multi, "black", color)) %>%
    select(node = t_id, category, color)
  
  domain.network.metadata = data.frame(node = unique(c(nucl.metabolism.domain.network$from, nucl.metabolism.domain.network$to))) %>%
    left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(node = id, label = name)) %>%
    mutate(size = 1) %>%
    left_join(domain.annotations, by = "node")
  
data.table::fwrite(domain.network.metadata, sprintf("%sFigure5/domain.network.metadata.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(nucl.metabolism.domain.network, sprintf("%sFigure5/nucl.metabolism.domain.network.txt", OUTPUT.FIGURES.PATH))

```



# Network of recent HGT
```{r}
recent_HGT_pairs_raw = protein.similarity.data %>%
  #filter(mosaic.pident70) %>%
  filter(mosaic.pident70) %>%
  select(qname, sname) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(qname, qindex = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(sname = qname, sindex = annotation.index)) %>%
  #filter(qindex != sindex & !is.na(qindex) & !is.na(sindex)) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(qname, sname)), collapse = " AND ", sep = "")) %>%
  ungroup()


recent_HGT_pairs = rbind( recent_HGT_pairs_raw %>%
  select(from = qindex, to = sindex, pair),
  recent_HGT_pairs_raw %>%
  select(to = qindex, from = sindex, pair)) %>%
  mutate(from = if_else(is.na(from),as.integer(0), from),
         to = if_else(is.na(to), as.integer(0), to)) %>%
  group_by(from, to) %>%
  summarise(num.prot.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  filter(num.prot.pairs >= 2) %>%
  filter(from <= to) %>%
  distinct() 
data.table::fwrite(recent_HGT_pairs, sprintf("%sFigure5/recent_HGT_network.txt", OUTPUT.FIGURES.PATH))
```

#Fig 4a and 4b Diversity of functional categories
```{r, fig.width = 10}
any.hit.stats = surely.annotated.ecod.domains.high.confidence %>%
  distinct(qname) %>%
  mutate(has.ecod.hit = 1) %>%
  right_join(surely.annotated.proteins %>% distinct(qname, annotation, category, annotation.index), by = "qname") %>%
  mutate(has.ecod.hit = if_else(is.na(has.ecod.hit), 0, has.ecod.hit)) %>%
  group_by(annotation, category, annotation.index) %>%
  summarise(num.proteins.with.ecod.hit = sum(has.ecod.hit)) %>%
  ungroup() %>%
  inner_join(included.category.sizes %>% filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION)) %>%
  mutate(prop.proteins.with.ecod.hit = num.proteins.with.ecod.hit/num.seq.per.annotation)

# only look at included categories (big enough)
num.prot.and.families.per.annot = surely.annotated.proteins.from.included.categories %>%
  group_by(annotation, category, annotation.index) %>%
  summarise(num.families = n_distinct(family),
            num.proteins = n_distinct(qname)) %>%
  ungroup()

num.domains.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(annotation, category, annotation.index) %>%
  summarise(num.t = n_distinct(t_id),
            num.h = n_distinct(h_id),
            num.x = n_distinct(x_id))

num.domain.combinations.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(qname, annotation, category, annotation.index) %>%
  summarise(all.t = paste(sort(unique(t_id)), collapse = " & "),
            all.h = paste(sort(unique(h_id)), collapse = " & "),
            all.x = paste(sort(unique(x_id)), collapse = " & ")) %>%
  group_by(annotation, category, annotation.index) %>%
  summarise(num.t.combinations = n_distinct(all.t),
            num.h.combinations = n_distinct(all.h),
            num.x.combinations = n_distinct(all.x))

diversity.data0 = num.prot.and.families.per.annot %>%
  left_join(num.domains.per.annnot, by = c('annotation', 'category', 'annotation.index'))  %>%
  left_join(num.domain.combinations.per.annnot, by = c('annotation', 'category', 'annotation.index')) %>%
  left_join(any.hit.stats, by = c('annotation', 'category', 'annotation.index')) %>%
  mutate(mean.no.of.folds.per.fold.type = num.t.combinations/num.seq.per.annotation) %>%
  select(annotation, category, annotation.index, num.families, num.proteins, num.topologies = num.t, num.topology.combinations = num.t.combinations, prop.proteins.with.ecod.hit, mean.no.of.folds.per.fold.type) %>%
  mutate(poorly.ecod.annotated = prop.proteins.with.ecod.hit < MIN.PROP.PROTS.WITH.ECOD.HIT)



no.fam.plotting.thr <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.families))[3]))
no.prot.plotting.thr <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.proteins))[3]))
no.ft.plotting.thr <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.topology.combinations))[3]))


no.prot.75.quant <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.proteins))[4]))
no.fam.75.quant <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.families))[4]))
no.ft.75.quant <- floor(as.numeric(quantile(diversity.data0 %>% 
                                                   filter(!poorly.ecod.annotated) %>% 
                                                   pull(num.topology.combinations))[4]))



diversity.data1 = diversity.data0 %>% 
  mutate(median.num.prot = no.prot.plotting.thr,
         median.num.fam = no.fam.plotting.thr,
        median.num.topology.combinations = no.ft.plotting.thr) %>%
  mutate(top.quantile = num.families >= median.num.fam & num.topology.combinations >= no.ft.plotting.thr & !poorly.ecod.annotated,
         bottom.quantile =  num.families <= median.num.fam & num.topology.combinations <= median.num.topology.combinations & !poorly.ecod.annotated,
         diverse.for.label = (num.families > no.fam.75.quant & num.topology.combinations > no.ft.75.quant) & !poorly.ecod.annotated) %>%
  #mutate(top.quantile = num.proteins > median.num.prot & num.topology.combinations > median.num.topology.combinations & !poorly.ecod.annotated,
         #bottom.quantile =  num.proteins <= median.num.prot & num.topology.combinations <= median.num.topology.combinations & !poorly.ecod.annotated,
         #diverse.for.label = (num.proteins > no.prot.75.quant & num.topology.combinations > no.ft.75.quant) & !poorly.ecod.annotated) %>%
  mutate(data.type = if_else(top.quantile, "top.diversity", if_else(bottom.quantile, "low.diversity", if_else(poorly.ecod.annotated, "poorly annotated", "unclear.diversity"))))

```




# sequence mosaicism 
```{r}
# Only looking at pairs of proteins where both are from the same functional category
seq.mosaicism.from.various.classes = protein.similarity.data %>%
  inner_join( surely.annotated.proteins %>% distinct(qname, annotation, category) %>% select(qname = qname, qannot = annotation)) %>%
  inner_join( surely.annotated.proteins %>% distinct(qname, annotation, category) %>% select(sname = qname, sannot = annotation)) %>%
  filter(qannot == sannot) %>%
  group_by(qannot) %>%
  summarise(prop.mosaic.pairs.sequence.thr0p1 = sum(mosaic.pident10)/n(),
            prop.mosaic.pairs.sequence.thr0p3 = sum(mosaic.pident30)/n(),
            prop.mosaic.pairs.sequence.thr0p5 = sum(mosaic.pident50)/n()) %>%
  select(annotation = qannot, prop.mosaic.pairs.sequence.thr0p1, prop.mosaic.pairs.sequence.thr0p3, prop.mosaic.pairs.sequence.thr0p5)


```


# Mosaicism and diversity per fold architecture (i.e. combination of domains)
```{r}
ecod.domains.in.qnames = surely.annotated.ecod.domains.high.confidence  %>%
  distinct(qname,family, annotation, category, x_id, t_id)

# first find all X level domains found
ecods.across.fold.types = ecod.domains.in.qnames %>%
  group_by(qname) %>%
  mutate(fold.type = paste(sort(unique(t_id)), collapse = " & ")) %>%
  ungroup() %>%
  distinct(t_id, x_id, fold.type, annotation, category)

all.x.and.t.within.fold.type = ecods.across.fold.types %>%
  group_by(fold.type, annotation, category) %>%
  summarise(all.x = paste(sort(unique(c(x_id))), collapse = " & "),
            num.x = n_distinct(x_id),
            num.t = n_distinct(t_id)) %>%
  ungroup()

num.folds.per.fold.type.data = all.x.and.t.within.fold.type %>%
  group_by(annotation, category) %>%
  summarise(mean.num.t = mean(num.t))

ecods.across.fold.types.data = ecods.across.fold.types %>% inner_join(all.x.and.t.within.fold.type) #%>% filter(num.x > 1)

fold.type.pairs.that.share.t = ecods.across.fold.types.data %>%
  inner_join(ecods.across.fold.types.data, by = c("annotation", "category", "t_id")) %>%
  filter(fold.type.x != fold.type.y) %>%
  left_join(ecods.across.fold.types %>% select(annotation, category, fold.type.x = fold.type, x.id.x = x_id)) %>%
  left_join(ecods.across.fold.types %>% select(annotation, category, fold.type.y = fold.type, x.id.y = x_id)) 

all.fold.type.pairs.sharing.t = fold.type.pairs.that.share.t %>%
  distinct(fold.type.x, fold.type.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(fold.type.x, fold.type.y)), collapse = " AND ", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.pairs = n_distinct(pair)) %>%
  ungroup()

fold.type.pairs.that.share.t.and.disshare.x = fold.type.pairs.that.share.t %>%
  filter(num.x.x > 1 & num.x.y > 1) %>%
  group_by(fold.type.x, fold.type.y, t_id, annotation, category) %>%
  mutate(all.x.within.both.fold.types = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ")) %>%
  ungroup() %>%
  left_join(all.x.and.t.within.fold.type %>% select(all.x.within.fold.type.x =all.x, fold.type.x = fold.type)) %>%
  left_join(all.x.and.t.within.fold.type %>% select(all.x.within.fold.type.y =all.x, fold.type.y = fold.type)) %>%
  filter(all.x.within.both.fold.types != all.x.within.fold.type.x & all.x.within.both.fold.types != all.x.within.fold.type.y) 

mosaicism.per.fold.type = fold.type.pairs.that.share.t.and.disshare.x %>%
  distinct(fold.type.x, fold.type.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(fold.type.x, fold.type.y)), collapse = " AND ", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.mosaic.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  left_join(all.fold.type.pairs.sharing.t) %>%
  mutate(prob.mosaicism = num.mosaic.pairs/num.pairs)


```


# Mosaicism and diversity per protein family
```{r shared-f-domains-not-x-domains}

ecod.domains.in.families = ecod.domains.in.qnames %>% distinct(x_id, t_id, family, annotation, category)
num.domains.per.family = ecod.domains.in.families %>%
  group_by(family, annotation, category) %>%
  summarise(num.t = n_distinct(t_id)) %>%
  ungroup() %>%
    group_by(annotation, category) %>%
    # median num t of those that have any T
  summarise(mean.num.t.per.prot = mean(num.t)) %>%
  ungroup()


# first find all X level domains found
ecods.across.families = ecod.domains.in.families %>%
  group_by(family, annotation, category) %>%
  summarise(num.x = n_distinct(x_id),
         all.x.names = paste(sort(unique(x_id)), collapse = " & ")) %>%
  ungroup() %>%
  distinct(family, annotation, category, all.x.names, num.x)

ecod.domains.in.families.data = ecod.domains.in.families %>% inner_join(ecods.across.families) #%>% filter(num.x > 1)

family.pairs.that.share.t = ecod.domains.in.families.data %>%
  inner_join(ecod.domains.in.families.data, by = c("annotation", "category", "t_id")) %>%
    filter(family.x != family.y) %>%
  left_join(ecod.domains.in.families.data %>% select(annotation, category, family.x = family, x.id.x = x_id)) %>%
  left_join(ecod.domains.in.families.data %>% select(annotation, category, family.y = family, x.id.y = x_id)) 

all.family.pairs.sharing.t = family.pairs.that.share.t %>%
  # only count pairs of families with at least two X
  filter(num.x.x > 1 & num.x.y > 1) %>%
  distinct(family.x, family.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.pairs = n_distinct(pair))

all.family.pairs.sharing.t.and.disshare.x = family.pairs.that.share.t %>%
  group_by(family.x, family.y, t_id, annotation, category) %>%
  mutate(all.x.within.both.families = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ")) %>%
  ungroup() %>%
  left_join(ecods.across.families %>% select(all.x.names.x =all.x.names, family.x = family)) %>%
  left_join(ecods.across.families %>% select(all.x.names.y =all.x.names, family.y = family)) %>%
  filter(all.x.within.both.families != all.x.names.x & all.x.within.both.families != all.x.names.y & all.x.names.y!= all.x.names.x) 

mosaicism.per.family = all.family.pairs.sharing.t.and.disshare.x %>%
  distinct(family.x, family.y, annotation, category) %>%
  rowwise() %>%
  mutate(pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>% 
  group_by(annotation, category)  %>%
  summarise(num.mosaic.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  left_join(all.family.pairs.sharing.t) %>%
  mutate(prob.mosaicism.if.sharing.fold.and.multi.x.family.measure = num.mosaic.pairs/num.pairs) %>%
  distinct(annotation, category, prob.mosaicism.if.sharing.fold.and.multi.x.family.measure)


diversity.data = diversity.data1 %>%
  left_join(mosaicism.per.fold.type) %>%
  left_join(num.folds.per.fold.type.data) %>%
  left_join(seq.mosaicism.from.various.classes) %>%
  left_join(mosaicism.per.family)  %>% 
  left_join(num.domains.per.family) 

```


#FIGURE 3B MOSAICISM
#ECOD MOSAICISM
```{r}

x.domains.per.qname = ecod.domains.hits %>%
  left_join(families) %>%
  group_by(qname, family) %>%
  summarise(num.x = n_distinct(x_id),
            all.x.names = paste(sort(unique(x_id)), collapse = " & ", sep = "")) 

ecod.domains.in.qnames.wih.multi.x = ecod.domains.hits %>%
  distinct(qname, t_id,x_id) %>%
  inner_join(x.domains.per.qname %>% filter(num.x > 1)) 

qname.pairs.that.share.t = ecod.domains.in.qnames.wih.multi.x %>%
  inner_join(ecod.domains.in.qnames.wih.multi.x, by = c("t_id")) %>%
    filter(qname.x < qname.y) 

qname.pairs.sharing.t.and.disshare.x = qname.pairs.that.share.t %>%
  filter(all.x.names.y!= all.x.names.x) %>%
  left_join(ecod.domains.in.qnames.wih.multi.x %>% select(qname.x = qname, x.id.x = x_id)) %>%
  left_join(ecod.domains.in.qnames.wih.multi.x %>% select(qname.y = qname, x.id.y = x_id)) %>%
  group_by(qname.x, qname.y, t_id) %>%
  mutate(all.x.within.both.families = paste(sort(unique(c(x.id.x, x.id.y))), collapse = " & ", sep = "")) %>%
  ungroup() %>%
  filter(all.x.within.both.families != all.x.names.x & all.x.within.both.families != all.x.names.y) 

qname.pairs.sharing.t.and.disshare.x.distinct = qname.pairs.sharing.t.and.disshare.x %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname.x = qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname.y = qname, annotation.index.to = annotation.index)) %>%
  distinct(qname.x, family.x, qname.y, family.y, t_id, all.x.names.x, all.x.names.y, all.x.within.both.families, annotation.index.from, annotation.index.to) %>%
  group_by(family.x, family.y) %>%
  mutate(family.pair = paste(sort(c(unique(family.x), unique(family.y))), collapse = "&", sep = "")) %>%
  ungroup() %>%
  group_by(qname.x, qname.y) %>%
  mutate(reprseq.pair = paste(sort(c(qname.x, qname.y)), collapse = "&", sep = "")) %>%
  ungroup()

```

#FIG 3C
# what domains are shared in mosaic pairs
```{r}
domains.shared.in.mosaic.pairs = qname.pairs.sharing.t.and.disshare.x.distinct %>%
  group_by(t_id) %>%
  summarise(num.family.pairs = n_distinct(family.pair),
            num.reprseq.pairs = n_distinct(reprseq.pair),
            num.unknown.family.pairs = n_distinct(family.pair[is.na(annotation.index.from) | is.na(annotation.index.to)]),
            num.known.family.pairs = n_distinct(family.pair[!is.na(annotation.index.from) & !is.na(annotation.index.to)])) %>%
  ungroup() %>%
  mutate(prop.family.pairs = num.family.pairs/n_distinct(qname.pairs.sharing.t.and.disshare.x.distinct$family.pair),
         prop.protein.pairs = num.reprseq.pairs/n_distinct(qname.pairs.sharing.t.and.disshare.x.distinct$reprseq.pair))


domains.shared.in.mosaic.pairs$h.index <- sapply(1:nrow(domains.shared.in.mosaic.pairs), function(index){
  this.topology <- domains.shared.in.mosaic.pairs$t_id[index]
  this.topology.h.index <- strsplit(this.topology, ".", fixed = T)[[1]]
  this.topology.h.index <- this.topology.h.index[-length(this.topology.h.index)]
  this.topology.h.index <- as.character(paste(this.topology.h.index, collapse = "."))
})

domains.shared.in.mosaic.pairs = domains.shared.in.mosaic.pairs %>%
    left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h.index = id, h_name = name)) %>%
    left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) 

data.table::fwrite(domains.shared.in.mosaic.pairs, file = sprintf("%sFigure3/domains-shared-by-mosaic-pairs.txt", OUTPUT.FIGURES.PATH))
```



# Fig 3B
```{r}

seq.mosaic.pairs = protein.similarity.data %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation.index) %>% select(sname = qname, annotation.index.to = annotation.index)) %>%
  filter(mosaic & qname < sname) %>%
  left_join(families %>% select(qname,qfamily = family)) %>%
  left_join(families %>% select(sname=qname,sfamily = family)) %>%
  group_by(qfamily, sfamily) %>%
  mutate(family.pair = paste(sort(c(unique(qfamily), unique(sfamily))), collapse = "&", sep = "")) %>%
  ungroup() %>%
  group_by(qname, sname) %>%
  mutate(reprseq.pair = paste(sort(c(qname, sname)), collapse = "&", sep = "")) %>%
  ungroup()

seq.mosaic.pairs.from.included.funct = seq.mosaic.pairs %>%
  # narrow down to included annotations only
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.from = annotation.index) %>% 
               distinct(annotation.index.from)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.to = annotation.index) %>% 
               distinct(annotation.index.to)) %>%
  distinct(qname, sname, annotation.index.from, annotation.index.to, family.pair, reprseq.pair, qfamily, sfamily) %>%
  mutate(mosaicism.type = "seq")


ecod.mosaic.pairs.from.included.funct = 
  qname.pairs.sharing.t.and.disshare.x.distinct %>%
    # narrow down to included annotations only
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.from = annotation.index) %>% 
               distinct(annotation.index.from)) %>%
  inner_join(included.category.sizes %>% 
               filter(annotation.coverage == DEFAULT.NINIMUM.COV.FOR.ANNOTATION) %>% 
               select(annotation.index.to = annotation.index) %>% 
               distinct(annotation.index.to)) %>%
  select(qname = qname.x, sname=qname.y, annotation.index.from, annotation.index.to, family.pair, reprseq.pair, qfamily = family.x, sfamily = family.y) %>%
  distinct() %>%
  mutate(mosaicism.type = "ecod")


mosaic.pairs.from.included.funct = # we may have the same pair twice if it is both mosaic by seq and by ecod
  rbind(seq.mosaic.pairs.from.included.funct, ecod.mosaic.pairs.from.included.funct) %>%
  group_by(annotation.index.from, annotation.index.to) %>%
  summarise(
    num.families.any.mosaic = n_distinct(family.pair),
    num.family.pairs.domain = n_distinct(family.pair[mosaicism.type == "ecod"]),
    num.family.pairs.seq = n_distinct(family.pair[mosaicism.type == "seq"]),
    num.reprseq.any.mossaic = n_distinct(reprseq.pair),
    num.reprseq.pairs.domain = n_distinct(reprseq.pair[mosaicism.type == "ecod"]),
    num.reprseq.pairs.seq = n_distinct(reprseq.pair[mosaicism.type == "seq"]),
    ) %>%
  ungroup() %>%
    #filter(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM | num.family.pairs.seq >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM) %>%
  #  mutate(mosaicism.type = if_else(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM & num.family.pairs.seq >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM, "both",
  #                                  if_else(num.family.pairs.domain >= MIN.NUM.FAMILY.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM, "ecod","seq"))) %>%
  filter(num.reprseq.any.mossaic >= MIN.NUM.REPRSEQ.PAIRS.FOR.BETWEEN.FUNCTION.MOSAICISM) %>%
  mutate(mosaicism.type = if_else(num.reprseq.pairs.domain > 0 & num.reprseq.pairs.seq > 0, "both",
                                    if_else(num.reprseq.pairs.domain > 0, "ecod","seq"))) %>%
    filter(annotation.index.from <= annotation.index.to)


mosaic.network = mosaic.pairs.from.included.funct %>%
  select(from.index = annotation.index.from, to.index = annotation.index.to, dataset = mosaicism.type, num.reprseq.any.mossaic, num.families.any.mosaic, num.reprseq.pairs.domain, num.reprseq.pairs.seq, num.family.pairs.domain, num.family.pairs.seq)
data.table::fwrite(mosaic.network, sprintf("%sFigure3/3a_mosaic.network.txt", OUTPUT.FIGURES.PATH))

mosaic.metadata = num.prot.and.families.per.annot %>%
  select(node = annotation.index, func = annotation, class = category, num.families, num.proteins)
data.table::fwrite(mosaic.metadata, sprintf("%sFigure3/3a_mosaic.metadata.txt", OUTPUT.FIGURES.PATH), sep = "\t")


#dd=Annotate_Graph(mosaic.network, 
#                               edge.colors = NULL, #mosaic.network %>% distinct(from.index, to.index,dataset),
#                               node.color.map = mosaic.metadata %>% select(node, category = class) %>% distinct() %>% left_join(color.map.df) %>% distinct(node, color),
#                               node.size.map = NULL,
#                               line.color.variable = 'num.reprseq.any.mossaic',
#                               vertex.size = 1)
#VisualiseGGnetwork(dd, vertex.size = 0.5, cex = 0.1, label_size = 3, layout = igraph::nicely(), main = "")

```


# new Fig 3c
```{r}

protein.similarity.data.no.self.hits = protein.similarity.data %>%
  filter(qname != sname & prob > 0 & scov > 0 & qcov > 0)
all.proteins.with.hit.to.anything = unique(c(protein.similarity.data.no.self.hits$qname, protein.similarity.data.no.self.hits$sname))
all.proteins.with.domain.mosaic.signal = unique(c(qname.pairs.sharing.t.and.disshare.x.distinct$qname.x, qname.pairs.sharing.t.and.disshare.x.distinct$qname.y))
all.proteins.with.seq.mosaic.signal = unique(c(seq.mosaic.pairs$qname, seq.mosaic.pairs$sname))
all.proteins.with.any.mosaic.signal = unique(c(all.proteins.with.domain.mosaic.signal, all.proteins.with.seq.mosaic.signal))


# look at the annotations at relaxed threhsold
all.proteins = repr.seq.lengths %>%
  select(qname = name) %>%
  distinct(qname) %>%
  mutate(mosaic = qname %in% all.proteins.with.any.mosaic.signal,
         mosaic.domain = qname %in% all.proteins.with.domain.mosaic.signal,
         mosaic.seq = qname %in% all.proteins.with.seq.mosaic.signal,
         has.hit.to.anything.in.the.data = qname %in% all.proteins.with.hit.to.anything,
         has.unknown.function = !(qname %in% surely.annotated.proteins.including.multi.annot$qname))


proteins.function.data = all.proteins %>%
  # filter(has.hit.to.anything.in.the.data & has.unknown.function) %>%
  left_join(families) %>%
  left_join(relaxely.annotated.proteins.including.multi.annot %>% select(qname, annotation, category, include)) %>%
  filter(include) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category))  %>%
  group_by(qname, family, mosaic) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))


table.seq.functions.new = proteins.function.data %>%
  #group_by(family, annotation, category, mosaic) %>%
  #summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category, mosaic) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight)) %>%
  mutate(mosaic = if_else(mosaic, "Mosaic", "Not mosaic")) %>%
  filter(annotation != "unknown") %>%
  group_by(mosaic) %>%
  mutate(total.weight = sum(weight)) %>%
  ungroup() %>%
  mutate(freq = weight/total.weight) 

data.table::fwrite(table.seq.functions.new, sprintf("%sFigure3/table.seq.functions.low.cov.txt", OUTPUT.FIGURES.PATH))
  
```









```{r}
annotated.qnames = surely.annotated.ecod.domains.high.confidence %>% distinct(qname) %>% pull(qname)
ecod.hits.data.table = surely.annotated.ecod.domains.high.confidence %>% 
        distinct(qname, annotation, qlength, qstart, qend, domain = t_id, family) %>% as.data.table()
ecod.hits.data.table = setDT(ecod.hits.data.table, key = 'qname')
seq2ecod.cov.list <- lapply(1:length(annotated.qnames), function(reprseq.index){
  this.reprseq <- annotated.qnames[reprseq.index]
  this.reprseq.hits <- ecod.hits.data.table[.(this.reprseq)]
  this.reprseq.domain.pos.list <- lapply(1:nrow(this.reprseq.hits), function(k) this.reprseq.hits$qstart[k]:this.reprseq.hits$qend[k])
  this.reprseq.domain.pos.unique <- unique(unlist(this.reprseq.domain.pos.list))
  return(ecod.pos = length(this.reprseq.domain.pos.unique))
})
seq2ecod.cov.df = data.frame(qname = annotated.qnames)
seq2ecod.cov.df$ecod.pos = seq2ecod.cov.list %>% unlist()
seq2ecod.cov.df = seq2ecod.cov.df %>%
  right_join(repr.seq.lengths %>% select(qname = name, length)) %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
    rowwise() %>%
    # those that were not in ecod data are all undetected
  mutate(num.detected.positions = if_else(is.na(ecod.pos), as.numeric(0), as.numeric(ecod.pos)))

ecod.coverage.data = seq2ecod.cov.df %>%
  group_by(annotation.index, annotation, category) %>%
  summarise(num.detected.positions = sum(num.detected.positions),
            num.all.positions = sum(length)) %>%
  ungroup() %>%
  mutate(prop.ecod.annotated.positions = num.detected.positions/num.all.positions) %>%
  select(annotation.index, annotation, category, prop.ecod.annotated.positions)

classes.with.few.ecod.annotated.prots.new = ecod.coverage.data %>%
  left_join(diversity.data %>% select(annotation, category, prop.proteins.with.ecod.hit)) %>%
  rename(`prot. with any ECOD hit` = prop.proteins.with.ecod.hit,
         `proteome covered by ECOD hits` =prop.ecod.annotated.positions) %>%
  arrange(`prot. with any ECOD hit`)

data.table::fwrite(classes.with.few.ecod.annotated.prots.new, sprintf("%sFigure_Supplementary/classes.with.few.ecod.annotated.txt", OUTPUT.FIGURES.PATH))
```



```{r, fig.width = 8, fig.width = 12}
all.proteins.with.any.relaxed.function = all.proteins %>%
  distinct(qname, mosaic) %>%
  left_join(relaxely.annotated.proteins.including.multi.annot) %>%
  filter(!is.na(annotation.index)) %>%
  group_by(annotation.index) %>%
  mutate(num.proteins.in.this.annotation = n_distinct(qname)) %>%
  ungroup() 

num.proteins.per.osaicism.data = all.proteins.with.any.relaxed.function %>%
  group_by(mosaic) %>%
  summarise(num.proteins = n_distinct(qname)) %>%
  ungroup()
  
annot.stats.per.category.and.mosaicism = all.proteins.with.any.relaxed.function %>%
  inner_join(diversity.data) %>%
  group_by(annotation.index, mosaic, annotation, category) %>%
  summarise(num.proteins.with.this.annot = n_distinct(qname)) %>%
  ungroup() %>%
  left_join(num.proteins.per.osaicism.data) %>%
  mutate(num.proteins.with.different.annot = num.proteins - num.proteins.with.this.annot,
         prop.proteins.has.this.annot = num.proteins.with.this.annot/num.proteins) %>%
  tidyr::complete(annotation.index, mosaic, fill = list(num.proteins = 0, num.proteins.with.this.annot = 0, num.proteins.with.different.annot = 0, prop.proteins.has.this.annot = NA))



annot.stats.per.category.and.mosaicism$pval = NA
annot.stats.per.category.and.mosaicism$odds.ratio = NA
for (this.annotation.index in unique(annot.stats.per.category.and.mosaicism$annotation.index)) {
  this.annot.stats = annot.stats.per.category.and.mosaicism %>% filter(annotation.index == this.annotation.index)
  M1 = this.annot.stats %>% select(mosaic, num.proteins.with.this.annot, num.proteins.with.different.annot) %>% select(num.proteins.with.this.annot, num.proteins.with.different.annot) %>% as.data.table()
#  annot.stats.per.category.and.mosaicism$pval[which(annot.stats.per.category.and.mosaicism$annotation.index == this.annotation.index)] = chisq.test(M1)$p.value
    annot.stats.per.category.and.mosaicism$pval[which(annot.stats.per.category.and.mosaicism$annotation.index == this.annotation.index)] = fisher.test(M1)$p.value
  annot.stats.per.category.and.mosaicism$odds.ratio[which(annot.stats.per.category.and.mosaicism$annotation.index == this.annotation.index)] = (M1$num.proteins.with.this.annot[2]/M1$num.proteins.with.different.annot[2])/(M1$num.proteins.with.this.annot[1]/M1$num.proteins.with.different.annot[1])
}
num.comparisons = n_distinct(annot.stats.per.category.and.mosaicism$annotation.index)
annot.stats.per.category.and.mosaicism = annot.stats.per.category.and.mosaicism %>%
  mutate(corrected.pval = pval*num.comparisons)
 
data.table::fwrite(annot.stats.per.category.and.mosaicism, file = sprintf("%sFigure3/unknown_functions_mosaic_vs_nonmosaic.txt", OUTPUT.FIGURES.PATH))

# test: domain Major cpasid protein GP7 is present in 121 proteins, 66 of them are known annotation (major capsid or structural protein)
# additionally 17 had a function that was not defined uniquely (capsid & structural protein)
# 116 of them were mosaic!
# 11 has sequence mosaicism and 111 had domain mosaicism!
# all 111 proteins with domain mosaicism had two domains: Major capsid protein gp5 & Major capsid protein GP7 (fold 3555.1.1, unknown X name)
# in the mosaic pairs they occured in the following combinations with 11 capsid proteins taht had a different fold architecture: 
# 1) Major capsid protein gp5 & Major capsid protein GP7  vs  Major capsid protein gp5 & Carbohydrate binding domain (probably also a capsid)
# 2) Major capsid protein gp5 & Major capsid protein GP7  vs  Major capsid protein gp5 & craddle loop barrel (probably also a capsid)
# 3) Major capsid protein gp5 & Major capsid protein GP7  vs  Major capsid protein gp5 & ClpP/crotonase (probably also a capsid)

```

# Domains within known and unknown proteins
```{r}
domains.within.proteins = all.proteins %>%
  # filter(has.hit.to.anything.in.the.data) %>%
  left_join(families) %>%
  inner_join(ecod.domains.hits, by = "qname") %>%
  group_by(mosaic) %>%
  mutate(total.num.families.with.any.ecod.hit = n_distinct(family),
         total.num.proteins.with.any.ecod.hit = n_distinct(qname)) %>%
  ungroup() %>%
  distinct(qname, family, t_id, t_name, mosaic, total.num.families.with.any.ecod.hit, total.num.proteins.with.any.ecod.hit) %>%
  group_by(t_id, t_name, mosaic, total.num.families.with.any.ecod.hit, total.num.proteins.with.any.ecod.hit) %>%
  summarise(num.families = n_distinct(family),
            num.proteins.with.this.ecod = n_distinct(qname)) %>%
  ungroup() %>%
  mutate(freq = num.families/total.num.families.with.any.ecod.hit,
         freq.q = num.proteins.with.this.ecod/total.num.proteins.with.any.ecod.hit,
         num.proteins.other.ecod.hits = total.num.proteins.with.any.ecod.hit - num.proteins.with.this.ecod) %>%
  tidyr::complete(t_id, mosaic, fill = list(num.proteins.with.this.ecod = 0, num.proteins.other.ecod.hits = 0))


domains.within.proteins$h.index <- sapply(1:nrow(domains.within.proteins), function(index){
  this.topology <- domains.within.proteins$t_id[index]
  this.topology.h.index <- strsplit(this.topology, ".", fixed = T)[[1]]
  this.topology.h.index <- this.topology.h.index[-length(this.topology.h.index)]
  this.topology.h.index <- as.character(paste(this.topology.h.index, collapse = "."))
})



domains.within.proteins$pval = NA
domains.within.proteins$odds.ratio = NA
for (this.t.id in unique(domains.within.proteins$t_id)) {
  this.domain.stats = domains.within.proteins %>% filter(t_id == this.t.id)
  M1 = this.domain.stats %>% select(mosaic, num.proteins.with.this.ecod, num.proteins.other.ecod.hits) %>% select(num.proteins.with.this.ecod, num.proteins.other.ecod.hits) %>% as.data.table()
  #domains.within.proteins$pval[which(domains.within.proteins$t_id == this.t.id)] = chisq.test(M1)$p.value
  domains.within.proteins$pval[which(domains.within.proteins$t_id == this.t.id)] = fisher.test(M1)$p.value
  domains.within.proteins$odds.ratio[which(domains.within.proteins$t_id == this.t.id)] = (M1$num.proteins.with.this.ecod[2]/M1$num.proteins.other.ecod.hits[2])/(M1$num.proteins.with.this.ecod[1]/M1$num.proteins.other.ecod.hits[1])
}

num.comparisons = n_distinct(domains.within.proteins$t_id)
domains.within.proteins = domains.within.proteins %>%
  mutate(corrected.pval = pval*num.comparisons)

domains.within.proteins = domains.within.proteins %>%
    left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h.index = id, h_name = name)) %>%
  mutate(mosaic = if_else(mosaic, "Mosaic", "Not mosaic"))
data.table::fwrite(domains.within.proteins, file = sprintf("%sFigure3/domains-in-known-and-unknown.txt", OUTPUT.FIGURES.PATH))


```

```{r}
# add some stats to diversity data
# mean seq length length and prop mosaic by sequence or domain

excel.filename = "Statistics.xlsx"

prop.mosaic.and.mean.length.per.category = all.proteins %>%  
  inner_join(surely.annotated.proteins.from.included.categories) %>%
  inner_join(repr.seq.lengths %>% select(qname = name, length)) %>%
  group_by(annotation.index, annotation, category) %>%
  summarise(prop.mosaic = n_distinct(qname[mosaic])/n_distinct(qname),
            mean.length = mean(length)) 


diversity.data2 = diversity.data %>%
  left_join(mosaic.pairs.from.included.funct %>% filter(annotation.index.from == annotation.index.to) %>% select(annotation.index = annotation.index.from, num.reprseq.pairs.domain)) %>%
  inner_join(prop.mosaic.and.mean.length.per.category)
data.table::fwrite(diversity.data2, sprintf("%sFigure4/Diversity_vs_mosaicism.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(diversity.data2 %>%
  filter(data.type == "top.diversity") %>%
    select(mean.num.t, prop.mosaic.pairs.sequence.thr0p1, prop.mosaic.pairs.sequence.thr0p3, prop.mosaic.pairs.sequence.thr0p5, 
           prob.mosaicism, num.mosaic.pairs, annotation, category, mean.num.t.per.prot, prob.mosaicism.if.sharing.fold.and.multi.x.family.measure, 
           prop.mosaic, num.reprseq.pairs.domain) %>%
  tidyr::gather(key = "proportion", value = "value", -c("annotation", "category")), 
  sprintf("%sFigure4/mosaicism.top.diverse.classes.txt", OUTPUT.FIGURES.PATH))


# mean length of sequences per data type
mean.seq.length.table = diversity.data2 %>% 
  filter(data.type %in% c("top.diversity", "low.diversity")) %>%
  group_by(data.type) %>% 
  summarise(mean.sequence.length = round(median(mean.length, na.rm = TRUE),1))
write.xlsx(x=mean.seq.length.table, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Mean seq length per data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)
test.longer.top.diverse = wilcox.test(x= diversity.data2 %>% filter(data.type == "top.diversity") %>% pull(mean.length), 
            y= diversity.data2 %>% filter(data.type == "low.diversity") %>% pull(mean.length), 
            paired = FALSE, alternative = "greater")
wilcox.test.data3 = data.frame(pval = test.longer.top.diverse$p.value,
                              statistic = test.longer.top.diverse$statistic)
write.xlsx(x=wilcox.test.data3, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Wilcox test seq length data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)





# test if top diversity functions are more mosaic than the low diversity oens
prop.mosaic.in.top.diverse.functions = diversity.data2 %>% filter(data.type == "top.diversity") %>% pull(prop.mosaic)
prop.mosaic.in.low.diverse.functions = diversity.data2 %>% filter(data.type == "low.diversity") %>% pull(prop.mosaic)
mean(prop.mosaic.in.top.diverse.functions)
mean(prop.mosaic.in.low.diverse.functions)
test.more.mosaic.top.diverse = wilcox.test(x= prop.mosaic.in.top.diverse.functions, 
            y= prop.mosaic.in.low.diverse.functions, 
            paired = FALSE, alternative = "greater")
wilcox.test.data = data.frame(pval = test.more.mosaic.top.diverse$p.value,
                              statistic = test.more.mosaic.top.diverse$statistic)
write.xlsx(x=wilcox.test.data, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Wilcox test prop. mosaic per data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)


# number of functional categories poorly and well annotated by ECOD
num.functional.categories.data = diversity.data %>% 
  distinct(annotation, category, poorly.ecod.annotated) %>%
  group_by(poorly.ecod.annotated) %>%
  summarise(n.classes = n())
write.xlsx(x=num.functional.categories.data, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Number of functional categories per data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)


# Correlation between num families/ num proteins and numbr of topology combinations
diversity.ok.ecod = diversity.data %>% filter(!poorly.ecod.annotated)
#ctest = cor.test(diversity.ok.ecod$num.families, diversity.ok.ecod$num.topology.combinations, method = "spearman")
ctest = cor.test(diversity.ok.ecod$num.proteins, diversity.ok.ecod$num.topology.combinations, method = "spearman")
ctesttable = data.frame(rho = ctest$estimate, p = ctest$p.value)
write.xlsx(x=ctesttable, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Correlation between two diversity measures", 
  col.names = TRUE, row.names = TRUE, append = TRUE)


# mean number of folds in low and top diversity functios
fold.number.per.data.type = diversity.data %>% 
  filter(data.type %in% c("top.diversity", "low.diversity")) %>%
  group_by(data.type) %>% 
  summarise(mean.num.folds = mean(mean.num.t, na.rm = TRUE))
write.xlsx(x=fold.number.per.data.type, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH,excel.filename), 
           sheetName = "Av. number of folds per data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)

test.more.folds.top.diverse = wilcox.test(x= diversity.data %>% filter(data.type == "top.diversity") %>% pull(mean.num.t), 
            y= diversity.data %>% filter(data.type == "low.diversity") %>% pull(mean.num.t), 
            paired = FALSE, alternative = "greater")
wilcox.test.data2 = data.frame(pval = test.more.folds.top.diverse$p.value,
                              statistic = test.more.folds.top.diverse$statistic)
write.xlsx(x=wilcox.test.data2, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "Wilcox test num folds per data type", 
  col.names = TRUE, row.names = TRUE, append = TRUE)




# some of the annotated may have hits to phrog classes with < 500 seq or may have multiple hits
num.proteins.with.unknown.function = all.proteins %>%
  group_by(has.unknown.function) %>%
  summarise(n = n())
write.xlsx(x=num.proteins.with.unknown.function, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = "num proteins.with unknown function", 
  col.names = TRUE, row.names = TRUE, append = TRUE)


aa = diversity.data %>% select(annotation, num.families, data.type) 
poorly_annotated_classes =  aa %>% filter(data.type== "poorly annotated") %>% arrange(desc(num.families))
write.xlsx(x=poorly_annotated_classes, 
           file = sprintf("%stables/%s", OUTPUT.FIGURES.PATH, excel.filename), 
           sheetName = " Poorly annotated classes", 
  col.names = TRUE, row.names = TRUE, append = TRUE)

n_distinct(surely.annotated.proteins.including.multi.annot %>% filter(num.annots == 1) %>% pull(qname))
n_distinct(repr.seq.lengths)

#mosaic.network %>% filter(num.reprseq.pairs.seq > 0 & num.reprseq.pairs.domain > 0 & from.index == to.index) %>% nrow()
#mosaic.network %>% filter(num.reprseq.pairs.seq > 0 | num.reprseq.pairs.domain > 0 & from.index == to.index) %>% nrow()
aa=all.proteins %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  group_by(annotation.index) %>%
  summarise(any.signal = any(mosaic.seq) | any(mosaic.domain),
            both.signal = any(mosaic.seq) & any(mosaic.domain))

sum(aa$any.signal)
sum(aa$both.signal)

```


#SHINY PLOTS: DOMAINS WITHIN FUNCTIONS
```{r}

most.mosaic.annotations = diversity.data %>% filter(data.type == "top.diversity") %>% arrange(desc(prob.mosaicism)) %>% head(12) %>% pull(annotation.index)
# too many domains if we include "tails"
tile.data.list = list()
i=0
domain_levels = c("T")
for (this.domain.level in domain_levels) {
this.domain.level.id = paste0(tolower(this.domain.level), "_id")

  for (this.annotation.index in most.mosaic.annotations) {
    domains.within.this.annotation = surely.annotated.ecod.domains.high.confidence %>% 
      filter(annotation.index == this.annotation.index) %>% 
        select(qname, annotation.index, annotation, qlength, qstart, qend, domain = this.domain.level.id, family)  %>% 
        group_by(qname) %>%
        mutate(all.domains = paste0(sort(unique(domain)), collapse = "_and_"),
               # this is just used for ordering
               first.domain = domain[qstart == min(qstart)][1]) %>%
        ungroup() 
    
    if (nrow(domains.within.this.annotation) > 0) {
      i=i+1
      tile.data = Get.Domain.Positions.Data(
        domains.within.this.annotation %>%
          # take only one representative per each domain combination and family combination
          group_by(all.domains, family) %>%
          mutate(first.domain = first.domain[1],
                  repr.qname = qname[1]) %>%
          ungroup() %>%
          filter(repr.qname == qname) %>%
        arrange(first.domain, family)) %>%
        mutate(annotation.index = this.annotation.index,
               annotation = unique(domains.within.this.annotation$annotation),
               domain.level = this.domain.level) %>%
        left_join(families, by = "qname")
      tile.data.list[[i]] = tile.data
          
    }
    else {print("no domains")}
  }
}


tile.data.raw = do.call('rbind', tile.data.list)
tile.data.raw.domains = tile.data.raw %>% distinct(domain)
tile.data.raw.domains$x.index <- sapply(1:nrow(tile.data.raw.domains), function(index){
  this.topology <- tile.data.raw.domains$domain[index]
  this.topology.x.index <- strsplit(this.topology, ".", fixed = T)[[1]][1] %>% as.character()
})



  x_index_ecod_map = ecod_id_to_names_map %>% 
                  filter(level == "X") %>%
                  mutate(id = as.character(id)) %>%
                  select(x.index = id, x_name = name) %>%
                  rbind(data.frame(x.index = c("undetected", "multiple domains")) %>%
                                   mutate(x_name = x.index))
  
    tile.data = tile.data.raw %>%
      left_join(ecod_id_to_names_map %>% 
                  select(domain = id, domain_name = name, domain.level = level) %>%
                  rbind(expand.grid(domain.level = unique(ecod_id_to_names_map$level), 
                                    domain = c("undetected", "multiple domains")) %>%
                                   mutate(domain_name = domain))) %>%
      left_join(tile.data.raw.domains) %>%
      left_join(x_index_ecod_map, by = "x.index") 
    
    data.table::fwrite(tile.data, sprintf("%sFigure5/domain.positions.txt", OUTPUT.FIGURES.PATH))
```

# Alternative Figures
## Folds shared by unknown proteins with any domain mosaicism signal
```{r}

unknwon.qname.pairs.sharing.t.and.disshare.x = qname.pairs.sharing.t.and.disshare.x.distinct %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation) %>% select(qname.x = qname, annotation.x = annotation)) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation) %>% select(qname.y = qname, annotation.y = annotation)) %>%
  filter(is.na(annotation.x) | is.na(annotation.y)) 

unknwon.mosaic.pairs = unknwon.qname.pairs.sharing.t.and.disshare.x %>%
  filter(qname.x < qname.y) %>%
  distinct(qname.x, qname.y, t_id, family.x, family.y) %>%
  rowwise() %>%
  mutate(protein.pair = paste(sort(c(qname.x, qname.y)), collapse = "&", sep = "")) %>% 
  ungroup() %>%
  group_by(family.x, family.y, t_id) %>%
  mutate(family.pair = paste(sort(c(family.x, family.y)), collapse = "&", sep = "")) %>%
  ungroup() %>%
  arrange(qname.x, qname.y) 


table.unknown.ecod = unknwon.mosaic.pairs %>%
  group_by(t_id) %>%
  summarise(num.pairs.of.families = n_distinct(family.pair),
            num.pairs.of.proteins = n_distinct(protein.pair)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) %>%
  arrange(desc(num.pairs.of.proteins)) 

table.unknown.ecod = table.unknown.ecod %>%
  mutate(total.family.pairs = n_distinct(unknwon.mosaic.pairs$family.pair),
         total.protein.pairs = n_distinct(unknwon.mosaic.pairs$protein.pair),
         freq = num.pairs.of.families/total.family.pairs,
         freq.q = num.pairs.of.proteins/total.protein.pairs)

table.unknowns.ecod.filename <- sprintf("%sFigure_Alternatives/table-unknown-ecod.txt", OUTPUT.FIGURES.PATH)
data.table::fwrite(table.unknown.ecod, file = table.unknowns.ecod.filename)
```


## Functions of unannotated proteins with any seq. mosaicism signal
```{r}
# Only looking at pairsof proteins where both are from the same functional category
 unknown.proteins.mosaic.pairs.table = seq.mosaic.pairs %>%
  # filter only those where at least one protein in a mosaic pair is unknown
  filter(is.na(annotation.index.from) | is.na(annotation.index.to)) %>%
  arrange(qname, sname)

unknown.qnames.with.mosaic.signal = unknown.proteins.mosaic.pairs.table %>% 
  filter(is.na(annotation.index.from)) %>% 
  pull(qname) %>%
  unique()

unknown.snames.with.mosaic.signal = unknown.proteins.mosaic.pairs.table %>% 
  filter(is.na(annotation.index.to)) %>% 
  pull(sname) %>%
  unique()

unknown.proteins.with.any.mosaic.signal = data.frame(qname = unique(c(unknown.qnames.with.mosaic.signal, unknown.snames.with.mosaic.signal))) %>%
  left_join(families, by = "qname") %>%
  # look not only at the included categories
  left_join(relaxely.annotated.proteins.including.multi.annot, #%>% filter(include), 
            by = c("qname", "family")) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category)) %>%
  group_by(qname, family) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))


table.unknown.seq = unknown.proteins.with.any.mosaic.signal %>%
  #group_by(family, annotation, category) %>%
  #summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight))

data.table::fwrite(table.unknown.seq, sprintf("%sFigure_Alternatives/table-unknown-seq.txt", OUTPUT.FIGURES.PATH))

```


## Functions of all unannotated proteins
```{r}
# Only looking at pairsof proteins where both are from the same functional category

 unknown.proteins.table = repr.seq.lengths %>%
  distinct(qname = name) %>%
  left_join(surely.annotated.proteins %>% distinct(qname,annotation)) %>%
  filter(is.na(annotation)) %>%
  distinct(qname) %>%
  left_join(families, by = "qname") %>%
  left_join(relaxely.annotated.proteins.including.multi.annot, #%>% filter(include), 
            by = c("qname", "family")) %>%
  mutate(annotation = if_else(is.na(annotation), "unknown", annotation)) %>%
  mutate(category = if_else(is.na(category), "unknown", category)) %>%
  group_by(qname, family) %>%
  mutate(num.hits = n_distinct(annotation[annotation != "unknown"]),
         annotation.weight = 1/num.hits,
         is.unannotated = if_else(num.hits == 0,1,0)) %>%
  ungroup() %>%
  mutate(this.annot.weight = if_else(annotation != "unknown", annotation.weight, is.unannotated))


table.all.unknown.seq = unknown.proteins.table %>%
  #group_by(family, annotation, category) %>%
  #summarise(annotation.weight = mean(this.annot.weight)) %>%
  group_by(annotation, category) %>%
  summarise(weight = sum(annotation.weight)) %>%
  ungroup() %>%
  arrange(desc(weight))

data.table::fwrite(table.all.unknown.seq, sprintf("%sFigure_Alternatives/table-all-unknown-seq.txt", OUTPUT.FIGURES.PATH))
```