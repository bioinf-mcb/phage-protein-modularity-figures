---
title: "analyse_data"
author: "Bogna Smug"
date: '2022-09-06'
output: html_document
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
dir.create(sprintf("%sFigure_Supplementary/ecod-coverage", OUTPUT.FIGURES.PATH))


families = data.table::fread(file = sprintf("%sfamilies.txt", OUTPUT.DATA.PATH)) 
protein.similarity.data = data.table::fread(file = sprintf("%sprotein.similarity.data.txt",OUTPUT.DATA.PATH)) 
repr.seq.lengths = data.table::fread(file = sprintf("%spython_pipeline/output/prot-families/representative/repr-seqs-lengths.txt", DATA.PATH)) 
ecod.domains.hits = data.table::fread(sprintf("%secod.domains.hits.txt",OUTPUT.DATA.PATH)) 
ecod_id_to_names_map = data.table::fread(sprintf("%secod_id_to_names_map.txt",OUTPUT.DATA.PATH)) %>% as.data.frame()
annotation.indices = data.table::fread(file = sprintf("%sannotation.indices",OUTPUT.DATA.PATH))
surely.annotated.proteins.including.multi.annot = data.table::fread( sprintf("%ssurely.annotated.proteins.including.multi.annot",OUTPUT.DATA.PATH))  %>%
  left_join(families) 
relaxely.annotated.proteins.including.multi.annot =data.table::fread(sprintf("%srelaxely.annotated.proteins.including.multi.annot",OUTPUT.DATA.PATH)) %>%
  left_join(families)  
protein.similarity.data.pident.above.30.pc = data.table::fread(file = sprintf("%sprotein.similarity.data.pident.above.30.pc.txt",OUTPUT.DATA.PATH))


num.prot.in.reprseq = data.table::fread(file = sprintf("%snum.prot.in.reprseq.txt", OUTPUT.DATA.PATH))
classes = rep("character", 16)
ecod.domain.descriptions = read.delim(ECOD.DOMAIN.DESCRIPTION.FILEPATH, 
                                      skip = 4, header = TRUE, 
                                      colClasses = classes, sep = "\t") 

color.map.df = PHROG.COLOR.MAP %>% stack()
names(color.map.df) = c("color", "category")
dir.create(sprintf("%sFigure_Supplementary/Supplementary_Tables", OUTPUT.FIGURES.PATH))
```

```{r}
index.cols = which(names(ecod.domains.hits) %in% c("x_id", "h_id", "t_id", "f_id"))
ecod.domains.hits[ , (index.cols) := lapply(.SD, as.character), .SDcols = index.cols]

unspecific.annotation.indices = surely.annotated.proteins.including.multi.annot  %>%
  mutate(unspecific = annotation %in% UNSPECIFIC.ANNOTATIONS) %>%
  filter(unspecific) %>%
  distinct(annotation.index) 

# disregard the ones with multiple annotations
# now surely.annotated.prteins includes all small categories
surely.annotated.proteins = GetUniquelyAnnotatedProteins(
  surely.annotated.proteins.including.multi.annot, 
  GENERAL.ANTIDEFENSE.ANNOTATION.INDEX, 
  unspecific.annotation.indices) 
data.table::fwrite(surely.annotated.proteins, sprintf("%ssurely.annotated.proteins.txt", OUTPUT.DATA.PATH))

reprseq.function.status = families %>%
  mutate(has.unknown.function = !(qname %in% surely.annotated.proteins.including.multi.annot$qname),
         not.unique.function = (qname %in% surely.annotated.proteins.including.multi.annot$qname & !(qname %in% surely.annotated.proteins$qname)))



included.annotation.indices = surely.annotated.proteins.including.multi.annot %>%
  group_by(annotation.index, include) %>%
    summarise(num.proteins.including.multi.annot = n_distinct(qname)) %>%
  ungroup() %>%
  filter(num.proteins.including.multi.annot >= MIN.NUM.PROT & include) %>%
  distinct(annotation.index) 

# We only include categories that have MIN.NUM.PROT (including the proteins with multiple annotation) as defined at high coverage threshold
included.category.sizes = surely.annotated.proteins %>%
              group_by(annotation.index) %>%
              summarise(
                  num.proteins = n_distinct(qname),
                  num.families = n_distinct(family)) %>%
               ungroup() %>%
  inner_join(included.annotation.indices)
data.table::fwrite(included.category.sizes, file = sprintf("%sincluded.category.sizes",OUTPUT.DATA.PATH))
data.table::fwrite(unspecific.annotation.indices, file = sprintf("%sunspecific.annotation.indices",OUTPUT.DATA.PATH))

```




# METADATA FOR NETWORKS
```{r}

node.color.map = included.category.sizes %>% 
  left_join(annotation.indices) %>%
                                      select(annotation.index, category) %>%
                                      left_join(color.map.df, by = "category") %>%
                                      select(node = annotation.index, color)
node.size.map = included.category.sizes %>% 
    left_join(annotation.indices) %>%
                                      mutate(node = annotation.index, size = log(num.families) + 1) %>%#num.proteins/100) %>%
                                      select(node, size) 
node.labels = included.category.sizes %>% 
    left_join(annotation.indices) %>%
                                      select(node = annotation.index, label = annotation)
included.categories.metadata = node.color.map %>%
  inner_join(node.size.map, by = "node") %>%
  inner_join(node.labels, by = "node") %>%
 rbind(
    data.frame(
      node = as.integer(UNKNOWN.ANNOTATION.INDEX),
      color = "#808080",
      size = (reprseq.function.status %>% filter(has.unknown.function | not.unique.function) %>% distinct(family) %>% nrow() %>% log()) + 1,
      label = "unknown"))

data.table::fwrite(included.categories.metadata, 
                   sprintf("%stables/included.categories.metadata.txt", OUTPUT.FIGURES.PATH))
```




# DOAMINS IN INCLUDED CATEGORIES
```{r}

surely.annotated.proteins.from.included.categories = surely.annotated.proteins %>%
  inner_join(included.annotation.indices) %>%
  select(qname, family, annotation.index)

surely.annotated.ecod.domains.high.confidence = ecod.domains.hits %>% 
  select(qname, qstart, qend, qlength, sstart, send, slength, x_id, h_id, t_id, f_id) %>%
  # note that some families may be unclassified i.e. d_id = NA
  inner_join(surely.annotated.proteins.from.included.categories)  
```

## Heatmap of H ECOD domains found in different functions
```{r, fig.height = 13}

# here we only look at included categories and only the specific ones
# surely.annotated.ecod.domains.high.confidence has only domains from qnames in included but may be not specific
num.h.per.q = surely.annotated.ecod.domains.high.confidence %>% 
  anti_join(unspecific.annotation.indices, by = "annotation.index") %>%
  distinct(qname, family, h_id, annotation.index) %>%
  inner_join(included.category.sizes %>% 
               select(annotation.index, num.proteins)) %>%
  group_by(annotation.index, qname) %>%
  summarise(num.h = n_distinct(h_id))
data.table::fwrite(num.h.per.q, sprintf("%sFigure_Supplementary/ecod-coverage/num.h.per.q.txt", OUTPUT.FIGURES.PATH))

av.num.h.per.qname = num.h.per.q %>%
  group_by(annotation.index) %>%
  summarise(median.nun.h = median(num.h),
            max.num.h = max(num.h))

h.domain.occurence.data = surely.annotated.ecod.domains.high.confidence %>% 
  anti_join(unspecific.annotation.indices, by = "annotation.index") %>%
  distinct(qname, family, h_id, annotation.index) %>%
  group_by(annotation.index, h_id) %>%
  summarise(num.prot.with.this.h.domain = n_distinct(qname),
            num.families.with.this.h.domain = n_distinct(family)) %>%
  inner_join(included.category.sizes %>% 
               select(annotation.index, num.proteins)) %>%
  mutate(occurence = num.prot.with.this.h.domain >= MIN.NUM.REPRSEQS.FOR.ECOD.PRESENCE) %>%
  filter(occurence) %>%
  mutate(h_id = as.character(h_id)) %>%
  left_join(annotation.indices, by = "annotation.index") %>%
  left_join(ecod_id_to_names_map %>% filter(level == "H") %>% select(h_id = id, h_name = name)) %>%
         # delete singletons
         group_by(h_id) %>%
         mutate(num_annot = n_distinct(annotation)) %>%
         filter(num_annot >= 3) %>%
  group_by(h_name) %>%
  mutate(num.categories = n_distinct(category)) %>%
  mutate(all.categories = if_else(num.categories == 1, 
                                  category, 
                                  "multiple categories")) %>%
  ungroup()
data.table::fwrite(h.domain.occurence.data, sprintf("%sFigure1/H_domains.txt", OUTPUT.FIGURES.PATH))

# keep the unspecific here, this will help us to find the most frequent category for each T
t.domain.occurence.data = surely.annotated.ecod.domains.high.confidence %>% 
  distinct(qname, family, t_id, annotation.index) %>%
  left_join(annotation.indices, by = "annotation.index") %>%
  group_by(category, t_id) %>%
  mutate(num.families.with.this.t.domain.and.category = n_distinct(family),
         num.reprseq.with.this.t.domain.and.category = n_distinct(qname)) %>%
  group_by(t_id) %>%
  mutate(most_frequent_category = paste0(unique(category[num.families.with.this.t.domain.and.category == max(num.families.with.this.t.domain.and.category)]), sep = "", collapse = " & ")) %>%
  group_by(annotation.index, t_id, annotation, category, most_frequent_category) %>%
  summarise(num.prot.with.this.t.domain = n_distinct(qname),
            num.families.with.this.t.domain = n_distinct(family)) 


t.domain.occurence.data.full = t.domain.occurence.data %>%
  anti_join(unspecific.annotation.indices, by = "annotation.index") %>%
  inner_join(included.category.sizes %>% 
               select(annotation.index, num.proteins)) %>%
  mutate(occurence = num.prot.with.this.t.domain >= MIN.NUM.REPRSEQS.FOR.ECOD.PRESENCE) %>%
  filter(occurence) %>%
  mutate(t_id = as.character(t_id)) %>%
  left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(t_id = id, t_name = name)) %>%
  group_by(t_name) %>%
  mutate(num.categories = n_distinct(category)) %>%
  mutate(all.categories = if_else(num.categories == 1, 
                                  category, 
                                  "multiple categories")) %>%
  ungroup()
dir.create(sprintf("%sFigure_Supplementary/T_domains", OUTPUT.FIGURES.PATH))
data.table::fwrite(t.domain.occurence.data.full, sprintf("%sFigure_Supplementary/T_domains/T_domains.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(t.domain.occurence.data, sprintf("%sFigure2/t.domain.occurence.data.txt", OUTPUT.FIGURES.PATH))



# here we also include annotations from included categories only
num.f.within.h = surely.annotated.ecod.domains.high.confidence  %>% 
  anti_join(unspecific.annotation.indices, by = "annotation.index") %>%
  group_by(h_id) %>% 
  summarise(num_f = n_distinct(f_id), 
            num_t = n_distinct(t_id), 
            num_prot = n_distinct(qname)) %>%
  left_join(h.domain.occurence.data %>% distinct(h_id, h_name, all.categories) %>% mutate(in.ecod.heatmap = TRUE)) %>%
  distinct(h_name, num_f, num_t, num_prot, all.categories, in.ecod.heatmap)
dir.create(sprintf("%sFigure_Supplementary/domain-div-freq-h/", OUTPUT.FIGURES.PATH))
data.table::fwrite(num.f.within.h, sprintf("%sFigure_Supplementary/domain-div-freq-h/num.f.within.h.txt", OUTPUT.FIGURES.PATH))
```

# ECOD coverage per category
```{r}
annotated.qnames = surely.annotated.ecod.domains.high.confidence %>% distinct(qname) %>% pull(qname)
ecod.hits.data.table = surely.annotated.ecod.domains.high.confidence %>% 
        distinct(qname, annotation.index, qlength, qstart, qend, domain = t_id, family) %>% as.data.table()
ecod.hits.data.table = setDT(ecod.hits.data.table, key = 'qname')
seq2ecod.cov.list <- lapply(1:length(annotated.qnames), function(reprseq.index){
  this.reprseq <- annotated.qnames[reprseq.index]
  this.reprseq.hits <- ecod.hits.data.table[.(this.reprseq)]
  this.reprseq.domain.pos.list <- lapply(1:nrow(this.reprseq.hits), function(k) this.reprseq.hits$qstart[k]:this.reprseq.hits$qend[k])
  this.reprseq.domain.pos.unique <- unique(unlist(this.reprseq.domain.pos.list))
  return(ecod.pos = length(this.reprseq.domain.pos.unique))
})
seq2ecod.cov.df = data.frame(qname = annotated.qnames)
seq2ecod.cov.df$ecod.pos = seq2ecod.cov.list %>% unlist()
seq2ecod.cov.df = seq2ecod.cov.df %>%
  right_join(families) %>%
  # in repr.seq.lengths we may have qnames that were deleted because of unaccepted characters
  left_join(repr.seq.lengths %>% select(qname = name, length)) %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
    rowwise() %>%
    # those that were not in ecod data are all undetected
  mutate(num.detected.positions = if_else(is.na(ecod.pos), as.numeric(0), as.numeric(ecod.pos)))

ecod.coverage.data = seq2ecod.cov.df %>%
  group_by(annotation.index) %>%
  summarise(num.detected.positions = sum(num.detected.positions),
            num.all.positions = sum(length)) %>%
  ungroup() %>%
  mutate(prop.ecod.annotated.positions = num.detected.positions/num.all.positions) %>%
  select(annotation.index, prop.ecod.annotated.positions)
```


# network of DNA, RNA, and nucleotide metabolism domains
```{r}
selected_categories = c("DNA, RNA and nucleotide metabolism","tail", "lysis")
domain.network.selected.categories = data.frame(from = character(0), to = character(0), category = character(0), num.prot = numeric(0))


for (selected_category in selected_categories) {
  domains.in.selected.category = surely.annotated.ecod.domains.high.confidence %>%
    left_join(annotation.indices) %>%
    filter(category == selected_category) %>%
    distinct(t_id, category)
  # here we look only at sequences that include a domain from selected category
  this.category.domain.hits = surely.annotated.ecod.domains.high.confidence %>%
    left_join(annotation.indices) %>%
    inner_join(domains.in.selected.category, by = c("t_id", "category")) %>%
    distinct(qname, t_id, category)
  # and we see what other doains coexist with these domains
  domain.network.this.category = this.category.domain.hits %>%
    inner_join(this.category.domain.hits, by = c("qname", "category")) %>%
    filter(t_id.x < t_id.y) %>%
    rowwise() %>%
    mutate(pair = CreatePair(t_id.x, t_id.y, collapse = " AND "),
           category = selected_category) %>%
    group_by(t_id.x, t_id.y, pair, category) %>%
    summarise(num.prot = n_distinct(qname)) %>%
    ungroup() %>%
    select(from = t_id.x, to = t_id.y, category, num.prot) #%>%
    #filter(num.prot >= 5)
    domain.network.selected.categories = rbind(domain.network.selected.categories, domain.network.this.category)
}



  domain.annotations = surely.annotated.ecod.domains.high.confidence %>%
    left_join(annotation.indices) %>%
    filter(category %in% selected_categories)  %>%
    group_by(t_id, category) %>%
    summarise(n = n_distinct(annotation),
              n.prot = n_distinct(qname),
              annotation = if_else(n == 1, annotation[1], "multiple")) %>%
    left_join(stack(PHROG.COLOR.MAP) %>% select(color = values, category = ind), by = "category") %>%
    mutate(multi = annotation == "multiple")  %>%
    mutate(color = if_else(multi, "black", color)) %>%
    select(node = t_id, category, color, n.prot)
  
  domain.network.metadata = data.frame(node = unique(c(domain.network.selected.categories$from, domain.network.selected.categories$to))) %>%
    left_join(ecod_id_to_names_map %>% filter(level == "T") %>% select(node = id, label = name)) %>%
    left_join(domain.annotations, by = "node")
 
dir.create(sprintf("%sFigure_Supplementary/domain_network", OUTPUT.FIGURES.PATH))
data.table::fwrite(domain.network.metadata, sprintf("%sFigure_Supplementary/domain_network/domain.network.metadata.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(domain.network.selected.categories, sprintf("%sFigure_Supplementary/domain_network/domain.network.selected.categories.txt", OUTPUT.FIGURES.PATH))

```



# Domain related stats per annot
#Fig 4a and 4b Diversity of functional categories
```{r, fig.width = 10}
any.hit.stats = surely.annotated.ecod.domains.high.confidence %>%
  distinct(qname) %>%
  mutate(has.ecod.hit = 1) %>%
  right_join(surely.annotated.proteins.from.included.categories %>% distinct(qname,annotation.index), by = "qname") %>%
  mutate(has.ecod.hit = if_else(is.na(has.ecod.hit), 0, has.ecod.hit)) %>%
  group_by(annotation.index) %>%
  summarise(num.proteins.with.ecod.hit = sum(has.ecod.hit)) %>%
  ungroup() %>%
  inner_join(included.category.sizes, by = c("annotation.index")) %>%
  mutate(prop.proteins.with.ecod.hit = num.proteins.with.ecod.hit/num.proteins) %>%
  mutate(poorly.ecod.annotated = prop.proteins.with.ecod.hit < MIN.PROP.PROTS.WITH.ECOD.HIT)

# only look at included categories (big enough)
num.domains.per.annnot = surely.annotated.ecod.domains.high.confidence %>%
  group_by(annotation.index) %>%
  summarise(num.t = n_distinct(t_id),
            num.h = n_distinct(h_id),
            num.x = n_distinct(x_id)) 

num.domain.combinations.per.qname = surely.annotated.ecod.domains.high.confidence %>%
  group_by(qname, annotation.index) %>%
  summarise(all.t = paste(sort(unique(t_id)), collapse = " & "),
            all.h = paste(sort(unique(h_id)), collapse = " & "),
            all.x = paste(sort(unique(x_id)), collapse = " & "),
            num.x = n_distinct(x_id),
            num.h = n_distinct(h_id)) %>%
  ungroup() 

num.domain.combinations.per.annnot = num.domain.combinations.per.qname %>%
  group_by(annotation.index) %>%
  summarise(num.t.combinations = n_distinct(all.t),
            num.h.combinations = n_distinct(all.h),
            num.x.combinations = n_distinct(all.x)) 



```



# Mosaicism by fold type
```{r}
fold.types.per.qname.and.domain = ecod.domains.hits %>%
  distinct(qname, x_id, t_id) %>%
  group_by(qname) %>%
  mutate(fold.type = paste(sort(unique(t_id)), collapse = " & ")) %>%
  ungroup()

fold.types.per.qname = fold.types.per.qname.and.domain %>%
  distinct(qname, fold.type) 

# here every row is one t or x that is seen in any qname, 
# additionally every qname is described by its fold type and all X and T that compose the fold type
# if one fold type is seen in two annotations, the rows will be repeated
ecods.across.fold.types = fold.types.per.qname.and.domain %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  distinct(t_id, x_id, fold.type, annotation.index) %>%
  group_by(fold.type, annotation.index) %>%
  mutate(all.x = paste(sort(unique(c(x_id))), collapse = " & "),
         num.x = n_distinct(x_id),
         num.t = n_distinct(t_id)) %>%
  ungroup()

data.table::fwrite(ecods.across.fold.types,
  sprintf("%sFigure_Supplementary/ecod-coverage/ecods.across.fold.types.txt", OUTPUT.FIGURES.PATH))


# first find all X level domains found
num.folds.per.fold.type.data = ecods.across.fold.types %>%
  group_by(annotation.index) %>%
  summarise(mean.num.t = mean(num.t))

fold.type.pairs.that.share.t.and.disshare.x = Get.Pairs.That.Share.T.And.Disshare.X(ecods.across.fold.types)
#mosaicism.per.fold.type = Calculate.Mosaicism.Per.Fold.Type(ecods.across.fold.types)
fold.type.mosaicism = Calculate.Num.Mosaic.Fold.Types(ecods.across.fold.types)
```
# sequence mosaicism 
```{r}

prot.length.per.qname = surely.annotated.proteins.from.included.categories %>%
  inner_join(repr.seq.lengths %>% select(qname = name, length))
data.table::fwrite(prot.length.per.qname, 
                   sprintf("%sFigure_Supplementary/ecod-coverage/prot.length.per.qname.txt", OUTPUT.FIGURES.PATH))

prot.lengths = prot.length.per.qname %>%
  group_by(annotation.index) %>%
  summarise(mean.length = mean(length)) 

  

multi.domain.props = surely.annotated.proteins.from.included.categories %>%
  left_join(num.domain.combinations.per.qname %>% select(qname, num.x, num.h), by = "qname") %>%
  mutate(num.x = if_else(is.na(num.x), 0, as.numeric(num.x)),
         num.h = if_else(is.na(num.h), 0, as.numeric(num.h))) %>%
  distinct(qname, annotation.index, num.x, num.h) %>%
  group_by(annotation.index) %>%
  summarise(num.with.multi.x.domains = sum(num.x > 1),
            num.with.multi.h.domains = sum(num.h > 1)) %>%
  ungroup() %>%
  left_join(included.category.sizes) %>%
  mutate(prop.with.multi.x.domains = num.with.multi.x.domains/num.proteins)
```




```{r}
diversity.data0 = included.category.sizes %>%
    anti_join(unspecific.annotation.indices) %>%
  left_join(num.domains.per.annnot, by = c('annotation.index'))  %>%
  left_join(num.domain.combinations.per.annnot, by = c('annotation.index')) %>%
  left_join(any.hit.stats, by = c('annotation.index', 'num.proteins', 'num.families')) %>%
  mutate(mean.no.of.folds.per.fold.type = num.t.combinations/num.proteins) %>%
  select(annotation.index, num.families, num.proteins, num.topologies = num.t, num.topology.combinations = num.t.combinations, prop.proteins.with.ecod.hit, mean.no.of.folds.per.fold.type, poorly.ecod.annotated)  %>%
  left_join(annotation.indices)  %>%
  left_join(prot.lengths) %>%
  left_join(av.num.h.per.qname) %>%
  #left_join(mosaicism.per.fold.type) %>%
  left_join(num.folds.per.fold.type.data) %>%
  #left_join(seq.mosaicism.from.various.classes) %>%
  left_join(ecod.coverage.data) %>%
  left_join(multi.domain.props)

#fam.quant.threshold = 0.5
#no.fam.thr <- as.numeric(quantile(diversity.data0$num.families,probs = fam.quant.threshold))
#no.fam.label.thr <- as.numeric(quantile(diversity.data0$num.families, probs = 0.75))

no.fam.thr = 20
no.fam.label.thr = 30

diversity.data = diversity.data0 %>% 
  mutate(threshold.num.fam  = no.fam.thr) %>%
  mutate(top.quantile = num.families >= threshold.num.fam,
         diverse.for.label = num.families >= no.fam.label.thr) %>%
  mutate(data.type = if_else(top.quantile, "top.diversity","low.diversity"))
data.table::fwrite(diversity.data, sprintf("%sFigure4/diversity.top.diverse.classes.txt", OUTPUT.FIGURES.PATH))
```







```{r}
# only join to included categoriews
seq.mosaic.pairs.all.pident = protein.similarity.data %>%
  filter(qname < sname & mosaic.pident10) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% 
              distinct(qname,annotation.index) %>% 
              select(qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% 
              distinct(qname,annotation.index) %>% 
              select(sname = qname, annotation.index.to = annotation.index)) %>%
  left_join(families %>% select(qname, qfamily = family)) %>%
  left_join(families %>% select(sname = qname, sfamily = family)) %>%
  group_by(qfamily, sfamily) %>%
  mutate(family.pair = CreatePair(qfamily, sfamily, collaps = "&")) %>%
  ungroup() %>%
  group_by(qname, sname) %>%
  mutate(reprseq.pair = CreatePair(qname, sname, collapse = "&")) %>%
  ungroup() 
```


```{r}
qname.pairs.sharing.t.and.disshare.x =   fold.type.pairs.that.share.t.and.disshare.x %>% 
  distinct(fold.type.x, fold.type.y, shared_t_id) %>% 
  rowwise() %>%
  mutate(fold.type.pair = CreatePair(fold.type.x, fold.type.y, collapse = "&")) %>%
  left_join(fold.types.per.qname %>% select(qname.x = qname, fold.type.x = fold.type), by = "fold.type.x", relationship = "many-to-many") %>%
  left_join(fold.types.per.qname %>% select(qname.y = qname,  fold.type.y = fold.type), by = "fold.type.y", relationship = "many-to-many") %>%
  left_join(families %>% select(qname.x = qname, family.x = family)) %>%
  left_join(families %>% select(qname.y = qname, family.y = family)) %>%
  group_by(family.x, family.y) %>%
  mutate(family.pair =CreatePair(family.x, family.y, collapse = "&") ) %>%
  ungroup() %>%
  group_by(qname.x, qname.y) %>%
  mutate(reprseq.pair = paste(sort(unique(c(qname.x, qname.y))), collapse = "&", sep = "")) %>%
  ungroup() %>%
  left_join(surely.annotated.proteins.from.included.categories %>% distinct(qname,annotation.index) %>% select(qname.x = qname, annotation.index.from = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% distinct(qname,annotation.index) %>% select(qname.y = qname, annotation.index.to = annotation.index)) %>%
  distinct(reprseq.pair, family.pair, fold.type.pair, qname.x, family.x, qname.y, family.y, shared_t_id, fold.type.x, fold.type.y, annotation.index.from, annotation.index.to) %>%
  arrange(reprseq.pair)
           #all.x.names.x, all.x.names.y, all.x.within.both.families, annotation.index.from, annotation.index.to) 
 # filtering is deleted so that we can group bt from annotation and to annotation and get the same results 
 #%>% 
  #filter(qname.x < qname.y) 

data.table::fwrite(qname.pairs.sharing.t.and.disshare.x, file = sprintf("%stables/qname.pairs.sharing.t.and.disshare.x.txt", OUTPUT.FIGURES.PATH))

```




# Mosaicism and diversity per fold architecture (i.e. combination of domains)
```{r}
qname.pairs.sharing.t.and.disshare.with.pident = qname.pairs.sharing.t.and.disshare.x %>%
  left_join(protein.similarity.data.pident.above.30.pc %>% distinct(reprseq.pair, pident)) %>%
  #left_join(seq.mosaic.pairs.all.pident %>% distinct(reprseq.pair, mosaic.pident50, mosaic.pident30, mosaic.pident70), by = "reprseq.pair") %>%
  group_by(fold.type.x, fold.type.y) %>%
  summarise(pident30 = any(pident >= 0.3, na.rm = TRUE),
            pident50 = any(pident >= 0.5, na.rm = TRUE),
            pident70 = any(pident >= 0.5, na.rm = TRUE))

fold.types.involved.in.mosaic.pairs = unique(c(qname.pairs.sharing.t.and.disshare.with.pident %>%
  distinct(fold.type.x) %>% pull(fold.type.x),
  qname.pairs.sharing.t.and.disshare.with.pident %>%
  distinct(fold.type.y) %>% pull(fold.type.y)))


fold.types.involved.in.mosaic.pairs.pident50 = unique(c(qname.pairs.sharing.t.and.disshare.with.pident %>%
  filter(pident50) %>% distinct(fold.type.x) %>% pull(fold.type.x),
  qname.pairs.sharing.t.and.disshare.with.pident %>%
  filter(pident50) %>% distinct(fold.type.y) %>% pull(fold.type.y)))


all.fold.types = ecods.across.fold.types %>%
  distinct(fold.type, t_id, x_id) %>%
  mutate(fold.type.mosaic = fold.type %in% fold.types.involved.in.mosaic.pairs,
         fold.type.mosaic.pident50 = fold.type %in% fold.types.involved.in.mosaic.pairs.pident50) 


all.t.in.fold.types = Get_Domain_Odss_In_Fold_Types(
  all.fold.types, 
  ecod_id_to_names_map)    
data.table::fwrite(all.t.in.fold.types, 
                   file = sprintf("%sFigure2/all.t.in.fold.types.txt", OUTPUT.FIGURES.PATH))

all.t.in.fold.types.pident50 = Get_Domain_Odss_In_Fold_Types(
  all.fold.types %>% 
       mutate(fold.type.mosaic = fold.type.mosaic.pident50), 
  ecod_id_to_names_map)    
data.table::fwrite(all.t.in.fold.types.pident50, file = sprintf("%sFigure2/all.t.in.fold.types_pident50.txt", OUTPUT.FIGURES.PATH))
```



```{r, eval = FALSE}
CheckSymmetry(qname.pairs.sharing.t.and.disshare.x, 'qname.x', 'qname.y')

```



# Fig 3B
```{r}


# here a pair will appear multiple times if it is mosaic by multiple definitions
all.potentially.mosaic.pairs =  
  qname.pairs.sharing.t.and.disshare.x  %>%
            mutate(mosaicism.type = "ecod") %>%
            select(family.pair, reprseq.pair, mosaicism.type) %>%
  left_join(protein.similarity.data.pident.above.30.pc %>% distinct(reprseq.pair, pident), by = "reprseq.pair") 


all.potentially.mosaic.pairs.from.included.functions =  
  rbind(
    all.potentially.mosaic.pairs  %>% 
      select(reprseq.pair, family.pair, mosaicism.type, pident) %>%
      tidyr::separate(col = reprseq.pair, into = c('qname.x', 'qname.y'), sep = "&", remove = FALSE) %>%
      left_join(surely.annotated.proteins.from.included.categories %>% select(qname.x = qname, annotation.index.from = annotation.index)) %>%
      left_join(surely.annotated.proteins.from.included.categories %>% select(qname.y = qname, annotation.index.to = annotation.index)),
    all.potentially.mosaic.pairs %>% 
      select(reprseq.pair, family.pair, mosaicism.type, pident) %>%
      tidyr::separate(col = reprseq.pair, into = c('qname.y', 'qname.x'), sep = "&", remove = FALSE) %>%
      left_join(surely.annotated.proteins.from.included.categories %>% select(qname.x = qname, annotation.index.from = annotation.index)) %>%
      left_join(surely.annotated.proteins.from.included.categories %>% select(qname.y = qname, annotation.index.to = annotation.index))) %>%
  select(reprseq.pair, family.pair, pident, qname.y, qname.x, mosaicism.type, annotation.index.from, annotation.index.to) %>%
  distinct() %>%
      # 0 means this is < 30%
  mutate(pident = if_else(is.na(pident), 0, pident))


# by pident we don't check length, use share.a.frahment,pident50 if you also want to restrict by prob and fragment length
mosaic.pairs.from.included.funct = all.potentially.mosaic.pairs.from.included.functions %>%
  group_by(annotation.index.from, annotation.index.to) %>%
  summarise(
    num.family.pairs.domain = n_distinct(family.pair[mosaicism.type == "ecod"]),
    num.family.pairs.recent.mosaic.seq.pident30 = n_distinct(family.pair[mosaicism.type == "ecod" & pident >= 0.3]),
    num.reprseq.pairs.recent.mosaic.seq.pident30 = n_distinct(reprseq.pair[mosaicism.type == "ecod" & pident >= 0.3]),
    num.family.pairs.recent.mosaic.seq.pident50 = n_distinct(family.pair[mosaicism.type == "ecod" & pident >= 0.5]),
    num.reprseq.pairs.recent.mosaic.seq.pident50 = n_distinct(reprseq.pair[mosaicism.type == "ecod" & pident >= 0.5]),
    num.family.pairs.recent.mosaic.seq.pident70 = n_distinct(family.pair[mosaicism.type == "ecod" & pident >= 0.7]),
    num.reprseq.pairs.recent.mosaic.seq.pident70 = n_distinct(reprseq.pair[mosaicism.type == "ecod" & pident >= 0.7]),
    num.reprseq.pairs.domain = n_distinct(reprseq.pair[mosaicism.type == "ecod"])
    ) %>%
  ungroup() %>%
  full_join(fold.type.mosaicism %>% 
              select(annotation.index.from = annotation.index.x, annotation.index.to = annotation.index.y, num.mosaic.fold.combination.pairs = num.mosaic.pairs)) %>%
  filter(annotation.index.from <= annotation.index.to) %>% 
  anti_join(unspecific.annotation.indices %>% select(annotation.index.from = annotation.index)) %>%
  anti_join(unspecific.annotation.indices %>% select(annotation.index.to = annotation.index)) %>%
  filter(!is.na(num.mosaic.fold.combination.pairs) & num.mosaic.fold.combination.pairs > 3)  %>%
   arrange(annotation.index.from, annotation.index.to) 


mosaic.network = mosaic.pairs.from.included.funct %>%
  select(from.index = annotation.index.from, 
         to.index = annotation.index.to, 
         num.reprseq.pairs.domain, 
         num.family.pairs.domain, 
         num.family.pairs.recent.mosaic.seq.pident30,
         num.reprseq.pairs.recent.mosaic.seq.pident30,
         num.family.pairs.recent.mosaic.seq.pident50,
         num.reprseq.pairs.recent.mosaic.seq.pident50,
         num.family.pairs.recent.mosaic.seq.pident70,
         num.reprseq.pairs.recent.mosaic.seq.pident70,
         num.mosaic.fold.combination.pairs) 

data.table::fwrite(mosaic.network, sprintf("%sFigure2/2b_mosaic.network.txt", OUTPUT.FIGURES.PATH))

mosaic.metadata = included.category.sizes %>%
  left_join(annotation.indices) %>%
  select(node = annotation.index, func = annotation, class = category, num.families, num.proteins) %>%
  left_join(diversity.data %>% select(node = annotation.index, num.topology.combinations))
data.table::fwrite(mosaic.metadata, sprintf("%sFigure2/2b_mosaic.metadata.txt", OUTPUT.FIGURES.PATH), sep = "\t")
```




# new Fig 3c
```{r, eval = FALSE}

protein.similarity.data.no.self.hits = protein.similarity.data %>%
  filter(qname != sname & prob > 0 & scov.max > 0 & qcov.max > 0)

all.proteins.with.hit.to.anything = unique(c(protein.similarity.data.no.self.hits$qname, protein.similarity.data.no.self.hits$sname))
all.proteins.with.mosaic.signal.pident30 = unique(c(seq.mosaic.pairs.all.pident %>% filter(mosaic.pident30) %>% pull(qname),
                                                seq.mosaic.pairs.all.pident %>% filter(mosaic.pident30) %>% pull(sname)))
all.proteins.with.mosaic.signal.pident50 = unique(c(seq.mosaic.pairs.all.pident %>% filter(mosaic.pident50) %>% pull(qname),
                                                seq.mosaic.pairs.all.pident %>% filter(mosaic.pident50) %>% pull(sname)))
all.proteins.with.mosaic.signal.pident70 = unique(c(seq.mosaic.pairs.all.pident %>% filter(mosaic.pident70) %>% pull(qname),
                                                seq.mosaic.pairs.all.pident %>% filter(mosaic.pident70) %>% pull(sname)))
all.proteins.with.mosaic.signal.pident90 = unique(c(seq.mosaic.pairs.all.pident %>% filter(mosaic.pident90) %>% pull(qname),
                                                seq.mosaic.pairs.all.pident %>% filter(mosaic.pident90) %>% pull(sname)))


```


```{r}
all.proteins.with.seq.mosaic.signal = unique(c(seq.mosaic.pairs.all.pident %>% filter(mosaic) %>% pull(qname),
                                                seq.mosaic.pairs.all.pident %>% filter(mosaic) %>% pull(sname)))
all.proteins.with.domain.mosaic.signal = unique(c(qname.pairs.sharing.t.and.disshare.x$qname.x, qname.pairs.sharing.t.and.disshare.x$qname.y))

all.proteins.with.any.mosaic.signal = unique(c(all.proteins.with.domain.mosaic.signal, all.proteins.with.seq.mosaic.signal))
# look at the annotations at relaxed threhsold
all.proteins = reprseq.function.status %>%
  mutate(mosaic = qname %in% all.proteins.with.any.mosaic.signal,
         mosaic.domain = qname %in% all.proteins.with.domain.mosaic.signal
         )
data.table::fwrite(all.proteins, sprintf("%sall.proteins.txt", OUTPUT.DATA.PATH))
data.table::fwrite(seq.mosaic.pairs.all.pident, sprintf("%sseq.mosaic.pairs.all.pident.txt", OUTPUT.DATA.PATH))
data.table::fwrite(qname.pairs.sharing.t.and.disshare.x, sprintf("%sqname.pairs.sharing.t.and.disshare.x.txt", OUTPUT.DATA.PATH))


```


```{r}
all.families = all.proteins %>% 
  group_by(family) %>%
  summarise(mosaic = any(mosaic),
            mosaic.domain = any(mosaic.domain))
  
# only families that have some specific annotations foom included categories
all.families.with.any.included.annotation = all.proteins %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
  anti_join(unspecific.annotation.indices) %>%
  distinct(family) %>%
  inner_join(all.families)


prop.mosaic.and.multidomain.data = all.proteins %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  left_join(included.category.sizes) %>%
  distinct(qname, annotation.index,mosaic.domain,mosaic, num.proteins) %>%
  group_by(annotation.index, num.proteins) %>%
  summarise(num.with.domain.mosaic.signal = sum(mosaic.domain),
            num.with.any.mosaic.signal = sum(mosaic)) %>%
  ungroup() %>%
  mutate(prop.with.domain.mosaic.signal = num.with.domain.mosaic.signal/num.proteins,
         prop.with.any.mosaic.signal = num.with.any.mosaic.signal/num.proteins)
  
prop.mosaic.families = all.proteins %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  left_join(included.category.sizes) %>%
  distinct(qname, annotation.index,num.families) %>%
  left_join(families) %>%
  left_join(all.families) %>%
  distinct(family, annotation.index, num.families, mosaic, mosaic.domain) %>%
  group_by(annotation.index, num.families) %>%
  summarise(num.with.domain.mosaic.signal = sum(mosaic.domain),
            num.with.any.mosaic.signal = sum(mosaic)) %>%
  ungroup() %>%
  mutate(prop.with.domain.mosaic.signal = num.with.domain.mosaic.signal/num.families,
         prop.with.any.mosaic.signal = num.with.any.mosaic.signal/num.families)


num.prots.from.specific.indices.per.domain = all.proteins %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  inner_join(included.category.sizes) %>%
  anti_join(unspecific.annotation.indices) %>%
  group_by(mosaic.domain) %>%
  summarise(num.proteins = n()) 

num.prots.from.specific.indices.per.seq.or.domain = all.proteins %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  inner_join(included.category.sizes) %>%
  anti_join(unspecific.annotation.indices) %>%
  group_by(mosaic) %>%
  summarise(num.proteins = n()) 


num.families.per.domain.mosaicism = all.families.with.any.included.annotation %>%
  group_by(mosaic.domain) %>%
  summarise(num.families= n()) 

num.families.per.seq.or.domain.mosaicism = all.families.with.any.included.annotation %>%
  group_by(mosaic) %>%
  summarise(num.families= n()) 


# This way we traet the whole family mosaic if there are some mosaic proteins in this family, even if they are from a different annotation
mosaic.domain.classes = all.proteins %>%
  distinct(qname, family, mosaic, mosaic.domain) %>%
  left_join(surely.annotated.proteins.from.included.categories) %>%
  inner_join(included.category.sizes) %>%
  anti_join(unspecific.annotation.indices) %>%
  left_join(all.families.with.any.included.annotation %>% select(family, family.mosaic = mosaic, family.mosaic.domain = mosaic.domain), by = "family") %>%
  group_by(annotation.index, num.proteins, num.families) %>%
  summarise(num.families.mosaic.domain = n_distinct(family[family.mosaic.domain]),
            num.families.mosaic.seq.or.domain = n_distinct(family[family.mosaic]),
            num.prot.mosaic.domain = sum(mosaic.domain),
            num.prot.mosaic.seq.or.domain = sum(mosaic)
            ) %>%
  ungroup() %>%
  mutate(num.families.nonmosaic.domain = num.families - num.families.mosaic.domain,
         num.families.nonmosaic.seq.or.domain = num.families - num.families.mosaic.seq.or.domain,
         num.families.mosaic.domain.other.functions = num.families.per.domain.mosaicism %>% filter(mosaic.domain) %>% pull(num.families) - num.families.mosaic.domain,
         num.families.nonmosaic.domain.other.functions = num.families.per.domain.mosaicism %>% filter(!mosaic.domain) %>% pull(num.families) - num.families.nonmosaic.domain,
         num.families.mosaic.seq.or.domain.other.functions = num.families.per.seq.or.domain.mosaicism %>% filter(mosaic) %>% pull(num.families) - num.families.mosaic.seq.or.domain,
         num.families.nonmosaic.seq.or.domain.other.functions = num.families.per.seq.or.domain.mosaicism %>% filter(!mosaic) %>% pull(num.families) - num.families.nonmosaic.seq.or.domain) %>%
  mutate(
         num.prot.nonmosaic.domain = num.proteins - num.prot.mosaic.domain,
         num.prot.nonmosaic.seq.or.domain = num.proteins - num.prot.mosaic.seq.or.domain,
         num.prot.mosaic.domain.other.functions = num.prots.from.specific.indices.per.domain %>% filter(mosaic.domain) %>% pull(num.proteins) - num.prot.mosaic.domain,
         num.prot.nonmosaic.domain.other.functions = num.prots.from.specific.indices.per.domain %>% filter(!mosaic.domain) %>% pull(num.proteins) - num.prot.nonmosaic.domain,
         num.prot.mosaic.seq.or.domain.other.functions = num.prots.from.specific.indices.per.seq.or.domain %>% filter(mosaic) %>% pull(num.proteins) - num.prot.mosaic.seq.or.domain,
         num.prot.nonmosaic.seq.or.domain.other.functions = num.prots.from.specific.indices.per.seq.or.domain %>% filter(!mosaic) %>% pull(num.proteins) - num.prot.nonmosaic.seq.or.domain
         ) %>%
  mutate(odds.seq.to.ecod = NA,#odds.seq.to.ecod = (num.families.mosaic.seq.or.domain/num.families.nonmosaic.seq.or.domain)/(num.families.mosaic.domain/num.families.nonmosaic.domain),
         pval.domain = NA,
         pval.seq.or.domain = NA) %>%
  left_join(annotation.indices)



 
 # test if some classes are overrepresented within mosaic families
  for (this.annotation.index in unique(mosaic.domain.classes$annotation.index)) {
    this.annot.stats = mosaic.domain.classes %>% filter(annotation.index == this.annotation.index)
    M1 = matrix(0, nrow=2, ncol = 2)
    M1[1,1] <- this.annot.stats$num.families.mosaic.domain
    M1[1,2] = this.annot.stats$num.families.nonmosaic.domain
    M1[2,1] = this.annot.stats$num.families.mosaic.domain.other.functions 
    M1[2,2] = this.annot.stats$num.families.nonmosaic.domain.other.functions
    #print(sum(M1))
    fisher_test_res = fisher.test(M1, alternative = "greater")
    mosaic.domain.classes$pval.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$p.value
    mosaic.domain.classes$odds.ratio.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$estimate %>% as.numeric()
    mosaic.domain.classes$odds.ratio.conf.lb.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$conf.int[1] %>% as.numeric()
    mosaic.domain.classes$odds.ratio.conf.ub.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$conf.int[2] %>% as.numeric()
    #mosaic.domain.classes$odds[which(mosaic.domain.classes$annotation.index == this.annotation.index)] =fisher_test_res$estimate
    M2 = matrix(0, nrow=2, ncol = 2)
    M2[1,1] <- this.annot.stats$num.families.mosaic.seq.or.domain
    M2[1,2] = this.annot.stats$num.families.nonmosaic.seq.or.domain
    M2[2,1] = this.annot.stats$num.families.mosaic.seq.or.domain.other.functions 
    M2[2,2] = this.annot.stats$num.families.nonmosaic.seq.or.domain.other.functions
    #print(sum(M2))
    fisher_test_res2 = fisher.test(M2, alternative = "greater")
    mosaic.domain.classes$pval.seq.or.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res2$p.value
    mosaic.domain.classes$odds.ratio.seq.or.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res2$estimate %>% as.numeric()
    mosaic.domain.classes$odds.ratio.conf.lb.seq.or.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res2$conf.int[1] %>% as.numeric()
     mosaic.domain.classes$odds.ratio.conf.ub.seq.or.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res2$conf.int[2] %>% as.numeric()
    
  }



 mosaic.domain.classes$pval.domain.corr = mosaic.domain.classes$pval.domain*length(unique(mosaic.domain.classes$annotation.index))
 mosaic.domain.classes$pval.seq.or.domain.corr = mosaic.domain.classes$pval.seq.or.domain*length(unique(mosaic.domain.classes$annotation.index))

data.table::fwrite(mosaic.domain.classes, sprintf("%sFigure4/mosaic.domain.classes.txt", OUTPUT.FIGURES.PATH))
#data.table::fwrite(mosaic.domain.classes.old, sprintf("%sFigure4/mosaic.domain.classes.old.txt", OUTPUT.FIGURES.PATH))

```

```{r, eval = FALSE}
 #  test if some classes are overrepresented within mosaic families( done on proteins)
 # for (this.annotation.index in unique(mosaic.domain.classes$annotation.index)) {
#    this.annot.stats = mosaic.domain.classes %>% filter(annotation.index == this.annotation.index)
 #   M1 = matrix(0, nrow=2, ncol = 2)
#    M1[1,1] <- this.annot.stats$num.prot.mosaic.domain
#    M1[1,2] = this.annot.stats$num.prot.nonmosaic.domain
#    M1[2,1] = this.annot.stats$num.prot.mosaic.domain.other.functions 
#    M1[2,2] = this.annot.stats$num.prot.nonmosaic.domain.other.functions
#    fisher_test_res = fisher.test(M1, alternative = "greater")
    #mosaic.domain.classes$pval.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$p.value
    #mosaic.domain.classes$odds[which(mosaic.domain.classes$annotation.index == this.annotation.index)] =fisher_test_res$estimate
#    M2 = matrix(0, nrow=2, ncol = 2)
#    M2[1,1] <- this.annot.stats$num.prot.mosaic.seq.or.domain
#    M2[1,2] = this.annot.stats$num.prot.nonmosaic.seq.or.domain
#    M2[2,1] = this.annot.stats$num.prot.mosaic.seq.or.domain.other.functions 
#    M2[2,2] = this.annot.stats$num.prot.nonmosaic.seq.or.domain.other.functions
#    fisher_test_res2 = fisher.test(M2, alternative = "greater")
    #mosaic.domain.classes$pval.seq.or.domain[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res2$p.value
    
#  }



# test if mosaic.seq.or.domain is overrepresented in some classes
#  for (this.annotation.index in unique(mosaic.domain.classes$annotation.index)) {
#    this.annot.stats = mosaic.domain.classes %>% filter(annotation.index == this.annotation.index)
#    M1 = matrix(0, nrow=2, ncol = 2)
#    M1[1,1] <- this.annot.stats$num.families.mosaic.seq.or.domain
#    M1[1,2] = this.annot.stats$num.families.nonmosaic.seq.or.domain
#    M1[2,1] = this.annot.stats$num.families.mosaic.domain 
#    M1[2,2] = this.annot.stats$num.families.nonmosaic.domain
#    fisher_test_res = fisher.test(M1, alternative = "greater")
    #mosaic.domain.classes$pval[which(mosaic.domain.classes$annotation.index == this.annotation.index)] = fisher_test_res$p.value
    #mosaic.domain.classes$odds.seq.to.ecod[which(mosaic.domain.classes$annotation.index == this.annotation.index)] =fisher_test_res$estimate
    
#  }

 
```






#SHINY PLOTS: DOMAINS WITHIN FUNCTIONS
```{r, eval = TRUE}

#most.mosaic.annotations = diversity.data %>% filter(data.type == "top.diversity") %>% arrange(desc(prob.mosaicism)) %>% head(12) %>% pull(annotation.index)
most.mosaic.annotations = diversity.data  %>% 
  filter(annotation %in% c("tail fiber","tail spike", "endolysin", "DNA polymerase")) %>% 
  pull(annotation.index)
# too many domains if we include "tails"
tile.data.list = list()
i=0
domain_levels = c("T")
for (this.domain.level in domain_levels) {
this.domain.level.id = paste0(tolower(this.domain.level), "_id")

  for (this.annotation.index in most.mosaic.annotations) {
    domains.within.this.annotation = surely.annotated.ecod.domains.high.confidence %>% 
      filter(annotation.index == this.annotation.index) %>% 
        select(qname, annotation.index, qlength, qstart, qend, domain = this.domain.level.id, family)  %>% 
        group_by(qname) %>%
        mutate(all.domains = paste0(sort(unique(domain)), collapse = "_and_"),
               # this is just used for ordering
               first.domain = domain[qstart == min(qstart)][1]) %>%
        ungroup()
    
    if (nrow(domains.within.this.annotation) > 0) {
      i=i+1
      # here we want to know how many reprseqs in a given family have a given domain combination
      num.prot.per.repr.arch = domains.within.this.annotation %>%
            distinct(qname, family, all.domains) %>%
            left_join(num.prot.in.reprseq, by = "qname") %>%
            group_by(all.domains, family) %>%
            # sum over all qnames from this family and domain architecture we will only look at number of sequences with this architecture AND with this annotation
            summarise(n.prot.in.arch = sum(n.prot.in.reprseq)) %>%
        ungroup()
 
     filtered.data.for.tiles = domains.within.this.annotation %>%
          # take only one representative per each domain combination and family combination
          # do not distinguish between A,B and B,A if within one family
            group_by(all.domains, family) %>%
            mutate(repr.qname = qname[1]) %>%
            ungroup() %>%
            filter(repr.qname == qname) %>%
       left_join(num.prot.per.repr.arch, by = c("all.domains", "family")) %>%
            arrange(first.domain, family)%>%
            mutate(annotation = annotation.index)
     
        
      tile.data = Get.Domain.Positions.Data(filtered.data.for.tiles) %>%
        mutate(annotation.index = this.annotation.index,
                domain.level = this.domain.level) %>%
        left_join(families, by = "qname")  %>%
        left_join(filtered.data.for.tiles %>% distinct(qname, n.prot.in.arch) %>% rename(n.prot.in.reprseq = n.prot.in.arch))
      tile.data.list[[i]] = tile.data
          
    }
    else {print("no domains")}
  }
}


tile.data.raw = do.call('rbind', tile.data.list)
tile.data.raw.domains = tile.data.raw %>% distinct(domain)
tile.data.raw.domains$x.index <- sapply(1:nrow(tile.data.raw.domains), function(index){
  this.topology <- tile.data.raw.domains$domain[index]
  this.topology.x.index <- strsplit(this.topology, ".", fixed = T)[[1]][1] %>% as.character()
})



  x_index_ecod_map = ecod_id_to_names_map %>% 
                  filter(level == "X") %>%
                  mutate(id = as.character(id)) %>%
                  select(x.index = id, x_name = name) %>%
                  rbind(data.frame(x.index = c("undetected", "multiple domains")) %>%
                                   mutate(x_name = x.index))
  
    tile.data = tile.data.raw %>%
      left_join(ecod_id_to_names_map %>% 
                  select(domain = id, domain_name = name, domain.level = level) %>%
                  rbind(expand.grid(domain.level = unique(ecod_id_to_names_map$level), 
                                    domain = c("undetected", "multiple domains")) %>%
                                   mutate(domain_name = domain))) %>%
      left_join(tile.data.raw.domains) %>%
      left_join(x_index_ecod_map, by = "x.index") %>%
      left_join(annotation.indices)
    
    data.table::fwrite(tile.data, sprintf("%sFigure3/domain.positions.txt", OUTPUT.FIGURES.PATH))
```



# Network of recent HGT
```{r}
dir.create(sprintf("%sFigure_Supplementary/network_recent_HGT", OUTPUT.FIGURES.PATH))
MIN.NUM.PAIRS.ONGOING.MOSAICISM = 1 

recent_HGT_pairs_raw.50 = protein.similarity.data %>%
  filter(mosaic.pident50) %>%
  select(qname, sname) %>%
  # we will get multiple rows if there are multiple observations
  # left_join(surely.annotated.proteins.including.multi.annot %>% select(qname, qindex = annotation.index)) %>%
  #left_join(surely.annotated.proteins.including.multi.annot %>% select(sname = qname, sindex = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(qname, qindex = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(sname = qname, sindex = annotation.index)) %>%
  left_join(included.annotation.indices %>% select(qindex = annotation.index) %>% mutate(qindex.icluded = TRUE)) %>%
  left_join(included.annotation.indices %>% select(sindex = annotation.index) %>% mutate(sindex.icluded = TRUE)) %>%
  #filter(qindex != sindex & !is.na(qindex) & !is.na(sindex)) %>%
  rowwise() %>%
  mutate(pair = CreatePair(qname, sname, collapse = "&")) %>%
  ungroup()  %>%
  # include true unknowns
  mutate(qindex.icluded = if_else(is.na(qindex), TRUE, qindex.icluded),
         sindex.icluded = if_else(is.na(sindex), TRUE, sindex.icluded))

dir.create(sprintf("%sFigure_Supplementary/network_recent_HGT", OUTPUT.FIGURES.PATH))
data.table::fwrite(recent_HGT_pairs_raw.50, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_pars_50.txt", OUTPUT.FIGURES.PATH))

recent_HGT_pairs_raw.70 = protein.similarity.data %>%
  filter(mosaic.pident70) %>%
  select(qname, sname) %>%
  #left_join(surely.annotated.proteins.including.multi.annot %>% select(qname, qindex = annotation.index)) %>%
  #left_join(surely.annotated.proteins.including.multi.annot %>% select(sname = qname, sindex = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(qname, qindex = annotation.index)) %>%
  left_join(surely.annotated.proteins.from.included.categories %>% select(sname = qname, sindex = annotation.index)) %>%
  left_join(included.annotation.indices %>% select(qindex = annotation.index) %>% mutate(qindex.icluded = TRUE)) %>%
  left_join(included.annotation.indices %>% select(sindex = annotation.index) %>% mutate(sindex.icluded = TRUE)) %>% 
  #filter(qindex != sindex & !is.na(qindex) & !is.na(sindex)) %>%
  rowwise() %>%
  mutate(pair = CreatePair(qname, sname, collapse = " AND ")) %>%
  ungroup() %>%
  # include true unknowns
  mutate(qindex.icluded = if_else(is.na(qindex), TRUE, qindex.icluded),
         sindex.icluded = if_else(is.na(sindex), TRUE, sindex.icluded))

recent_HGT_pairs.70 = rbind( 
  recent_HGT_pairs_raw.70 %>%
    # only show on network inlcuded categories
  filter(qindex.icluded & sindex.icluded) %>%
  select(from = qindex, to = sindex, pair),
  recent_HGT_pairs_raw.70 %>%
  filter(qindex.icluded & sindex.icluded) %>%
  select(to = qindex, from = sindex, pair)) %>%
  mutate(from = if_else(is.na(from),as.integer(UNKNOWN.ANNOTATION.INDEX), from),
         to = if_else(is.na(to), as.integer(UNKNOWN.ANNOTATION.INDEX), to)) %>%
  group_by(from, to) %>%
  summarise(num.prot.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  filter(num.prot.pairs >= MIN.NUM.PAIRS.ONGOING.MOSAICISM) %>%
  filter(from <= to) %>%
  distinct() 

data.table::fwrite(recent_HGT_pairs.70, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_network_70.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(recent_HGT_pairs_raw.70, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_pars_70.txt", OUTPUT.FIGURES.PATH))


recent_HGT_pairs_raw.90 = protein.similarity.data %>%
  filter(mosaic.pident90) %>%
  select(qname, sname) %>%
  left_join(surely.annotated.proteins %>% select(qname, qindex = annotation.index)) %>%
  left_join(surely.annotated.proteins %>% select(sname = qname, sindex = annotation.index)) %>%
  left_join(included.annotation.indices %>% select(qindex = annotation.index) %>% mutate(qindex.icluded = TRUE)) %>%
  left_join(included.annotation.indices %>% select(sindex = annotation.index) %>% mutate(sindex.icluded = TRUE)) %>% 
  #filter(qindex != sindex & !is.na(qindex) & !is.na(sindex)) %>%
  rowwise() %>%
  mutate(pair = CreatePair(qname, sname, collapse = " AND ")) %>%
  ungroup() %>%
  # include true unknowns
  mutate(qindex.icluded = if_else(is.na(qindex), TRUE, qindex.icluded),
         sindex.icluded = if_else(is.na(sindex), TRUE, sindex.icluded))


recent_HGT_pairs.90 = rbind( 
  recent_HGT_pairs_raw.90 %>%
      filter(qindex.icluded & sindex.icluded) %>%
      select(from = qindex, to = sindex, pair),
  recent_HGT_pairs_raw.90 %>%
      filter(qindex.icluded & sindex.icluded) %>%
      select(to = qindex, from = sindex, pair)) %>%
  mutate(from = if_else(is.na(from),as.integer(UNKNOWN.ANNOTATION.INDEX), from),
         to = if_else(is.na(to), as.integer(UNKNOWN.ANNOTATION.INDEX), to)) %>%
  group_by(from, to) %>%
  summarise(num.prot.pairs = n_distinct(pair)) %>%
  ungroup() %>%
  filter(num.prot.pairs >= MIN.NUM.PAIRS.ONGOING.MOSAICISM) %>%
  filter(from <= to) %>%
  distinct() 

data.table::fwrite(recent_HGT_pairs.90, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_network_90.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(recent_HGT_pairs_raw.90, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_pars_90.txt", OUTPUT.FIGURES.PATH))


recent_HGT_pairs_raw.90.to.study.examples = 
  recent_HGT_pairs_raw.90 %>%
  left_join(annotation.indices %>% select(qindex = annotation.index, qannotation = annotation)) %>%
  left_join(annotation.indices %>% select(sindex = annotation.index, sannotation = annotation))


recent_HGT_pairs_raw.70.to.study.examples = 
  recent_HGT_pairs_raw.70 %>%
  left_join(annotation.indices %>% select(qindex = annotation.index, qannotation = annotation)) %>%
  left_join(annotation.indices %>% select(sindex = annotation.index, sannotation = annotation))
data.table::fwrite(recent_HGT_pairs_raw.90.to.study.examples, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_pairs_raw.90.to.study.examples.txt", OUTPUT.FIGURES.PATH))
data.table::fwrite(recent_HGT_pairs_raw.70.to.study.examples, sprintf("%sFigure_Supplementary/network_recent_HGT/recent_HGT_pairs_raw.70.to.study.examples.txt", OUTPUT.FIGURES.PATH))

# things from small categories wi;; be trated as unknown
```


# SEQUENCE MOSAICISM HEATMAP
```{r}
# only filter to those with minimum length and high probability
dir.create(sprintf("%sFigure_Supplementary/pident-maxcov", OUTPUT.FIGURES.PATH))
 filtered.protein.similarity.data = protein.similarity.data %>% filter(share.any.fragment)
data.table::fwrite(filtered.protein.similarity.data, sprintf("%sFigure_Supplementary/pident-maxcov/cov.vs.pident.txt", OUTPUT.FIGURES.PATH))
```

```{r}
MIN.NUM = 3
aa=all.proteins %>%
  inner_join(surely.annotated.proteins.from.included.categories) %>%
  anti_join(unspecific.annotation.indices) %>%
  group_by(annotation.index) %>%
  summarise(domain.signal = sum(mosaic.domain))

bb = data.frame(
 domain.signal = sum(aa$domain.signal >= MIN.NUM),
 all.classes = nrow(aa))

print(bb)
```



```{r, eval = TRUE}
hhr.table = read.csv("/Users/bognasmug/MGG Dropbox/Projects/divRBP/phage-pp-workdir-refseq-hhblits/output/prot-families/all-by-all/hhblits/table-hhr.txt", 
                     sep = ",",
                     header = TRUE)

# some hits are missing in hhr table 
recent_HGT_pairs_raw.domain.data.all.pident50 = Get.Recent.HGT.Domains(
  # distinct to make sure we don;t count the same pair twice
  recent_HGT_pairs_raw = recent_HGT_pairs_raw.50 %>% distinct(qname, sname), 
  # note that technically pident and prob in the raw hhr.tabl may not be the same as within our summarised table we used before
  # make the hhr table symmetric so that every reprseq is seen on qname position
  hhr.table = hhr.table %>% filter(prob >= MINIMUM.PROB.FOR.PAIRWISE.HIT & pident >= 50),
  surely.annotated.proteins.from.included.categories %>%
    left_join(annotation.indices), 
  ecod.domains.hits)

recent_HGT_pairs_raw.domain.data.all.pident70 = Get.Recent.HGT.Domains(
  recent_HGT_pairs_raw = recent_HGT_pairs_raw.70 %>% distinct(qname, sname), 
  # note that technically pident and prob in the raw hhr.tabl may not be the same as within our summarised table we used before
  # make the hhr table symmetric so that every reprseq is seen on qname position
  hhr.table = hhr.table %>% filter(prob >= MINIMUM.PROB.FOR.PAIRWISE.HIT & pident >= 70),
  surely.annotated.proteins.from.included.categories %>%
    left_join(annotation.indices), 
  ecod.domains.hits)

recent_HGT_pairs_raw.domain.data.all.pident90 = Get.Recent.HGT.Domains(
  recent_HGT_pairs_raw = recent_HGT_pairs_raw.90 %>% distinct(qname, sname), 
  hhr.table = hhr.table %>% filter(prob >= MINIMUM.PROB.FOR.PAIRWISE.HIT & pident >= 90), 
  surely.annotated.proteins.from.included.categories %>%
    left_join(annotation.indices), 
  ecod.domains.hits)

 #dnapolymerase.recent_HGT_pairs_raw.domain.data = recent_HGT_pairs_raw.domain.data.all.pident90 %>%
#    filter(qannot == "DNA polymerase" | sannot == "DNA polymerase")
 

write.csv(recent_HGT_pairs_raw.domain.data.all.pident70, sprintf("%sFigure_Supplementary/recent_HGT_domains.pident70.csv", OUTPUT.FIGURES.PATH))
write.csv(recent_HGT_pairs_raw.domain.data.all.pident90, sprintf("%sFigure_Supplementary/recent_HGT_domains.pident90.csv", OUTPUT.FIGURES.PATH))
```


